(function () {
  'use strict';

  class ChatButton extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this.isOpen = false;

      const style = document.createElement('style');
      style.textContent = `
      :host {
        display: block;
        --primary-color: linear-gradient(135deg, #63a3f7 0%, #2F80ED 100%);
--hover-effect: brightness(1.09) saturate(1.2);

      }

      .chat-bubble {
        position: fixed;
        bottom: 25px;
        right: 25px;
        width: 70px;
        height: 70px;
        background: var(--primary-color);
        border-radius: 50%;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 9990;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        border: none;
        overflow: hidden;
      }

      .chat-bubble::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .chat-bubble:hover {
        transform: scale(1.1);
        filter: var(--hover-effect);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
      }

      .chat-bubble:hover::after {
        opacity: 1;
      }

      :host([position="bottom-left"]) .chat-bubble {
        left: 25px;
        right: auto;
      }

      .chat-bubble__icon {
        width: 30px;
        height: 30px;
        margin-bottom: 4px;
        z-index: 1;
      }

      .chat-bubble__text {
        color: white;
        font-size: 0.7rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        z-index: 1;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      @keyframes floating {
        0% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
        100% { transform: translateY(0); }
      }

      .chat-bubble {
        animation: floating 3s ease-in-out infinite;
      }

      @media (max-width: 480px) {
        .chat-bubble {
          width: 63px;
          height: 63px;
          bottom: var(--mobile-bottom, 40px);
          right: var(--mobile-right, 20px);
          left: var(--mobile-left, auto);
        }
      }
    `;

      const template = document.createElement('template');
      template.innerHTML = `
      <div class="chat-bubble">
        <svg class="chat-bubble__icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
        </svg>
        <span class="chat-bubble__text">Help</span>
      </div>
    `;

      this.shadowRoot.appendChild(style);
      this.shadowRoot.appendChild(template.content.cloneNode(true));
      this.bubbleElement = this.shadowRoot.querySelector('.chat-bubble');
    }

    connectedCallback() {
      this.bubbleElement.addEventListener('click', () => {
        this.isOpen = !this.isOpen;
        // يمكنك إضافة منطق إضافي للتفاعل مع النقر هنا
      });
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (name === 'position' && oldValue !== newValue) {
        const positionMap = {
          'bottom-left': { left: '25px', right: 'auto' },
          'bottom-right': { right: '25px', left: 'auto' }
        };
        Object.assign(this.bubbleElement.style, positionMap[newValue] || positionMap['bottom-right']);
      }

      if (name === 'mobile-position') {
        const mobilePositions = newValue.split(' ');
        this.style.setProperty('--mobile-bottom', mobilePositions[0]);
        this.style.setProperty('--mobile-right', mobilePositions[1]);
        this.style.setProperty('--mobile-left', mobilePositions[2]);
      }
    }

    static get observedAttributes() {
      return ['position', 'mobile-position'];
    }
  }

  customElements.define('chat-button', ChatButton);

  /**
   * marked v15.0.11 - a markdown parser
   * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)
   * https://github.com/markedjs/marked
   */

  /**
   * DO NOT EDIT THIS FILE
   * The code in this file is generated from files in ./src/
   */

  /**
   * Gets the original marked default options.
   */
  function _getDefaults() {
      return {
          async: false,
          breaks: false,
          extensions: null,
          gfm: true,
          hooks: null,
          pedantic: false,
          renderer: null,
          silent: false,
          tokenizer: null,
          walkTokens: null,
      };
  }
  let _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
      _defaults = newDefaults;
  }

  const noopTest = { exec: () => null };
  function edit(regex, opt = '') {
      let source = typeof regex === 'string' ? regex : regex.source;
      const obj = {
          replace: (name, val) => {
              let valSource = typeof val === 'string' ? val : val.source;
              valSource = valSource.replace(other.caret, '$1');
              source = source.replace(name, valSource);
              return obj;
          },
          getRegex: () => {
              return new RegExp(source, opt);
          },
      };
      return obj;
  }
  const other = {
      codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
      outputLinkReplace: /\\([\[\]])/g,
      indentCodeCompensation: /^(\s+)(?:```)/,
      beginningSpace: /^\s+/,
      endingHash: /#$/,
      startingSpaceChar: /^ /,
      endingSpaceChar: / $/,
      nonSpaceChar: /[^ ]/,
      newLineCharGlobal: /\n/g,
      tabCharGlobal: /\t/g,
      multipleSpaceGlobal: /\s+/g,
      blankLine: /^[ \t]*$/,
      doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
      blockquoteStart: /^ {0,3}>/,
      blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
      blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
      listReplaceTabs: /^\t+/,
      listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
      listIsTask: /^\[[ xX]\] /,
      listReplaceTask: /^\[[ xX]\] +/,
      anyLine: /\n.*\n/,
      hrefBrackets: /^<(.*)>$/,
      tableDelimiter: /[:|]/,
      tableAlignChars: /^\||\| *$/g,
      tableRowBlankLine: /\n[ \t]*$/,
      tableAlignRight: /^ *-+: *$/,
      tableAlignCenter: /^ *:-+: *$/,
      tableAlignLeft: /^ *:-+ *$/,
      startATag: /^<a /i,
      endATag: /^<\/a>/i,
      startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
      endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
      startAngleBracket: /^</,
      endAngleBracket: />$/,
      pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
      unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
      escapeTest: /[&<>"']/,
      escapeReplace: /[&<>"']/g,
      escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
      escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
      unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
      caret: /(^|[^\[])\^/g,
      percentDecode: /%25/g,
      findPipe: /\|/g,
      splitPipe: / \|/,
      slashPipe: /\\\|/g,
      carriageReturn: /\r\n|\r/g,
      spaceLine: /^ +$/gm,
      notSpaceStart: /^\S*/,
      endingNewline: /\n$/,
      listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`),
      nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
      hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
      fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
      headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
      htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),
  };
  /**
   * Block-Level Grammar
   */
  const newline = /^(?:[ \t]*(?:\n|$))+/;
  const blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  const bullet = /(?:[*+-]|\d{1,9}[.)])/;
  const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
  const lheading = edit(lheadingCore)
      .replace(/bull/g, bullet) // lists can interrupt
      .replace(/blockCode/g, /(?: {4}| {0,3}\t)/) // indented code blocks can interrupt
      .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
      .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
      .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
      .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
      .replace(/\|table/g, '') // table not in commonmark
      .getRegex();
  const lheadingGfm = edit(lheadingCore)
      .replace(/bull/g, bullet) // lists can interrupt
      .replace(/blockCode/g, /(?: {4}| {0,3}\t)/) // indented code blocks can interrupt
      .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
      .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
      .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
      .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
      .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/) // table can interrupt
      .getRegex();
  const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  const blockText = /^[^\n]+/;
  const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  const def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/)
      .replace('label', _blockLabel)
      .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
      .getRegex();
  const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
      .replace(/bull/g, bullet)
      .getRegex();
  const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'
      + '|tr|track|ul';
  const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  const html$2 = edit('^ {0,3}(?:' // optional indentation
      + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
      + '|comment[^\\n]*(\\n+|$)' // (2)
      + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
      + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
      + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
      + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' // (6)
      + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' // (7) open tag
      + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' // (7) closing tag
      + ')', 'i')
      .replace('comment', _comment)
      .replace('tag', _tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();
  const paragraph = edit(_paragraph)
      .replace('hr', hr)
      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
      .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
      .replace('|table', '')
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
      .getRegex();
  const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
      .replace('paragraph', paragraph)
      .getRegex();
  /**
   * Normal Block Grammar
   */
  const blockNormal = {
      blockquote,
      code: blockCode,
      def,
      fences,
      heading,
      hr,
      html: html$2,
      lheading,
      list,
      newline,
      paragraph,
      table: noopTest,
      text: blockText,
  };
  /**
   * GFM Block Grammar
   */
  const gfmTable = edit('^ *([^\\n ].*)\\n' // Header
      + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
      + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)') // Cells
      .replace('hr', hr)
      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
      .replace('blockquote', ' {0,3}>')
      .replace('code', '(?: {4}| {0,3}\t)[^\\n]')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', _tag) // tables can be interrupted by type (6) html blocks
      .getRegex();
  const blockGfm = {
      ...blockNormal,
      lheading: lheadingGfm,
      table: gfmTable,
      paragraph: edit(_paragraph)
          .replace('hr', hr)
          .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
          .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
          .replace('table', gfmTable) // interrupt paragraphs with table
          .replace('blockquote', ' {0,3}>')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
          .getRegex(),
  };
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */
  const blockPedantic = {
      ...blockNormal,
      html: edit('^ *(?:comment *(?:\\n|\\s*$)'
          + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
          + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
          .replace('comment', _comment)
          .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
          .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest, // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(_paragraph)
          .replace('hr', hr)
          .replace('heading', ' *#{1,6} *[^\n]')
          .replace('lheading', lheading)
          .replace('|table', '')
          .replace('blockquote', ' {0,3}>')
          .replace('|fences', '')
          .replace('|list', '')
          .replace('|html', '')
          .replace('|tag', '')
          .getRegex(),
  };
  /**
   * Inline-Level Grammar
   */
  const escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  const br = /^( {2,}|\\)\n(?!\s*$)/;
  const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  // list of unicode punctuation marks, plus any missing characters from CommonMark spec
  const _punctuation = /[\p{P}\p{S}]/u;
  const _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
  const _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
  const punctuation = edit(/^((?![*_])punctSpace)/, 'u')
      .replace(/punctSpace/g, _punctuationOrSpace).getRegex();
  // GFM allows ~ inside strong and em for strikethrough
  const _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
  const _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
  const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
  // sequences em should skip over [title](link), `code`, <html>
  const blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
  const emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
  const emStrongLDelim = edit(emStrongLDelimCore, 'u')
      .replace(/punct/g, _punctuation)
      .getRegex();
  const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')
      .replace(/punct/g, _punctuationGfmStrongEm)
      .getRegex();
  const emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' // Skip orphan inside strong
      + '|[^*]+(?=[^*])' // Consume to delim
      + '|(?!\\*)punct(\\*+)(?=[\\s]|$)' // (1) #*** can only be a Right Delimiter
      + '|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter
      + '|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter
      + '|[\\s](\\*+)(?!\\*)(?=punct)' // (4) ***# can only be Left Delimiter
      + '|(?!\\*)punct(\\*+)(?!\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter
      + '|notPunctSpace(\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter
  const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')
      .replace(/notPunctSpace/g, _notPunctuationOrSpace)
      .replace(/punctSpace/g, _punctuationOrSpace)
      .replace(/punct/g, _punctuation)
      .getRegex();
  const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')
      .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)
      .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)
      .replace(/punct/g, _punctuationGfmStrongEm)
      .getRegex();
  // (6) Not allowed for _
  const emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' // Skip orphan inside strong
      + '|[^_]+(?=[^_])' // Consume to delim
      + '|(?!_)punct(_+)(?=[\\s]|$)' // (1) #___ can only be a Right Delimiter
      + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter
      + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter
      + '|[\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter
      + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter
      .replace(/notPunctSpace/g, _notPunctuationOrSpace)
      .replace(/punctSpace/g, _punctuationOrSpace)
      .replace(/punct/g, _punctuation)
      .getRegex();
  const anyPunctuation = edit(/\\(punct)/, 'gu')
      .replace(/punct/g, _punctuation)
      .getRegex();
  const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
      .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
      .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
      .getRegex();
  const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
  const tag = edit('^comment'
      + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
      + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
      + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
      + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
      + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>') // CDATA section
      .replace('comment', _inlineComment)
      .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
      .getRegex();
  const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  const link = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/)
      .replace('label', _inlineLabel)
      .replace('href', /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/)
      .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
      .getRegex();
  const reflink = edit(/^!?\[(label)\]\[(ref)\]/)
      .replace('label', _inlineLabel)
      .replace('ref', _blockLabel)
      .getRegex();
  const nolink = edit(/^!?\[(ref)\](?:\[\])?/)
      .replace('ref', _blockLabel)
      .getRegex();
  const reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
      .replace('reflink', reflink)
      .replace('nolink', nolink)
      .getRegex();
  /**
   * Normal Inline Grammar
   */
  const inlineNormal = {
      _backpedal: noopTest, // only used for GFM url
      anyPunctuation,
      autolink,
      blockSkip,
      br,
      code: inlineCode,
      del: noopTest,
      emStrongLDelim,
      emStrongRDelimAst,
      emStrongRDelimUnd,
      escape: escape$1,
      link,
      nolink,
      punctuation,
      reflink,
      reflinkSearch,
      tag,
      text: inlineText,
      url: noopTest,
  };
  /**
   * Pedantic Inline Grammar
   */
  const inlinePedantic = {
      ...inlineNormal,
      link: edit(/^!?\[(label)\]\((.*?)\)/)
          .replace('label', _inlineLabel)
          .getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
          .replace('label', _inlineLabel)
          .getRegex(),
  };
  /**
   * GFM Inline Grammar
   */
  const inlineGfm = {
      ...inlineNormal,
      emStrongRDelimAst: emStrongRDelimAstGfm,
      emStrongLDelim: emStrongLDelimGfm,
      url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
          .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
          .getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
  };
  /**
   * GFM + Line Breaks Inline Grammar
   */
  const inlineBreaks = {
      ...inlineGfm,
      br: edit(br).replace('{2,}', '*').getRegex(),
      text: edit(inlineGfm.text)
          .replace('\\b_', '\\b_| {2,}\\n')
          .replace(/\{2,\}/g, '*')
          .getRegex(),
  };
  /**
   * exports
   */
  const block = {
      normal: blockNormal,
      gfm: blockGfm,
      pedantic: blockPedantic,
  };
  const inline = {
      normal: inlineNormal,
      gfm: inlineGfm,
      breaks: inlineBreaks,
      pedantic: inlinePedantic,
  };

  /**
   * Helpers
   */
  const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
  };
  const getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape(html, encode) {
      if (encode) {
          if (other.escapeTest.test(html)) {
              return html.replace(other.escapeReplace, getEscapeReplacement);
          }
      }
      else {
          if (other.escapeTestNoEncode.test(html)) {
              return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
          }
      }
      return html;
  }
  function cleanUrl(href) {
      try {
          href = encodeURI(href).replace(other.percentDecode, '%');
      }
      catch {
          return null;
      }
      return href;
  }
  function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      const row = tableRow.replace(other.findPipe, (match, offset, str) => {
          let escaped = false;
          let curr = offset;
          while (--curr >= 0 && str[curr] === '\\')
              escaped = !escaped;
          if (escaped) {
              // odd number of slashes means | is escaped
              // so we leave it alone
              return '|';
          }
          else {
              // add space before unescaped |
              return ' |';
          }
      }), cells = row.split(other.splitPipe);
      let i = 0;
      // First/last cell in a row cannot be empty if it has no leading/trailing pipe
      if (!cells[0].trim()) {
          cells.shift();
      }
      if (cells.length > 0 && !cells.at(-1)?.trim()) {
          cells.pop();
      }
      if (count) {
          if (cells.length > count) {
              cells.splice(count);
          }
          else {
              while (cells.length < count)
                  cells.push('');
          }
      }
      for (; i < cells.length; i++) {
          // leading or trailing whitespace is ignored per the gfm spec
          cells[i] = cells[i].trim().replace(other.slashPipe, '|');
      }
      return cells;
  }
  /**
   * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
   * /c*$/ is vulnerable to REDOS.
   *
   * @param str
   * @param c
   * @param invert Remove suffix of non-c chars instead. Default falsey.
   */
  function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
          return '';
      }
      // Length of suffix matching the invert condition.
      let suffLen = 0;
      // Step left until we fail to match the invert condition.
      while (suffLen < l) {
          const currChar = str.charAt(l - suffLen - 1);
          if (currChar === c && true) {
              suffLen++;
          }
          else {
              break;
          }
      }
      return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
          return -1;
      }
      let level = 0;
      for (let i = 0; i < str.length; i++) {
          if (str[i] === '\\') {
              i++;
          }
          else if (str[i] === b[0]) {
              level++;
          }
          else if (str[i] === b[1]) {
              level--;
              if (level < 0) {
                  return i;
              }
          }
      }
      if (level > 0) {
          return -2;
      }
      return -1;
  }

  function outputLink(cap, link, raw, lexer, rules) {
      const href = link.href;
      const title = link.title || null;
      const text = cap[1].replace(rules.other.outputLinkReplace, '$1');
      lexer.state.inLink = true;
      const token = {
          type: cap[0].charAt(0) === '!' ? 'image' : 'link',
          raw,
          href,
          title,
          text,
          tokens: lexer.inlineTokens(text),
      };
      lexer.state.inLink = false;
      return token;
  }
  function indentCodeCompensation(raw, text, rules) {
      const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
      if (matchIndentToCode === null) {
          return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text
          .split('\n')
          .map(node => {
          const matchIndentInNode = node.match(rules.other.beginningSpace);
          if (matchIndentInNode === null) {
              return node;
          }
          const [indentInNode] = matchIndentInNode;
          if (indentInNode.length >= indentToCode.length) {
              return node.slice(indentToCode.length);
          }
          return node;
      })
          .join('\n');
  }
  /**
   * Tokenizer
   */
  class _Tokenizer {
      options;
      rules; // set by the lexer
      lexer; // set by the lexer
      constructor(options) {
          this.options = options || _defaults;
      }
      space(src) {
          const cap = this.rules.block.newline.exec(src);
          if (cap && cap[0].length > 0) {
              return {
                  type: 'space',
                  raw: cap[0],
              };
          }
      }
      code(src) {
          const cap = this.rules.block.code.exec(src);
          if (cap) {
              const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');
              return {
                  type: 'code',
                  raw: cap[0],
                  codeBlockStyle: 'indented',
                  text: !this.options.pedantic
                      ? rtrim(text, '\n')
                      : text,
              };
          }
      }
      fences(src) {
          const cap = this.rules.block.fences.exec(src);
          if (cap) {
              const raw = cap[0];
              const text = indentCodeCompensation(raw, cap[3] || '', this.rules);
              return {
                  type: 'code',
                  raw,
                  lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                  text,
              };
          }
      }
      heading(src) {
          const cap = this.rules.block.heading.exec(src);
          if (cap) {
              let text = cap[2].trim();
              // remove trailing #s
              if (this.rules.other.endingHash.test(text)) {
                  const trimmed = rtrim(text, '#');
                  if (this.options.pedantic) {
                      text = trimmed.trim();
                  }
                  else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
                      // CommonMark requires space before trailing #s
                      text = trimmed.trim();
                  }
              }
              return {
                  type: 'heading',
                  raw: cap[0],
                  depth: cap[1].length,
                  text,
                  tokens: this.lexer.inline(text),
              };
          }
      }
      hr(src) {
          const cap = this.rules.block.hr.exec(src);
          if (cap) {
              return {
                  type: 'hr',
                  raw: rtrim(cap[0], '\n'),
              };
          }
      }
      blockquote(src) {
          const cap = this.rules.block.blockquote.exec(src);
          if (cap) {
              let lines = rtrim(cap[0], '\n').split('\n');
              let raw = '';
              let text = '';
              const tokens = [];
              while (lines.length > 0) {
                  let inBlockquote = false;
                  const currentLines = [];
                  let i;
                  for (i = 0; i < lines.length; i++) {
                      // get lines up to a continuation
                      if (this.rules.other.blockquoteStart.test(lines[i])) {
                          currentLines.push(lines[i]);
                          inBlockquote = true;
                      }
                      else if (!inBlockquote) {
                          currentLines.push(lines[i]);
                      }
                      else {
                          break;
                      }
                  }
                  lines = lines.slice(i);
                  const currentRaw = currentLines.join('\n');
                  const currentText = currentRaw
                      // precede setext continuation with 4 spaces so it isn't a setext
                      .replace(this.rules.other.blockquoteSetextReplace, '\n    $1')
                      .replace(this.rules.other.blockquoteSetextReplace2, '');
                  raw = raw ? `${raw}\n${currentRaw}` : currentRaw;
                  text = text ? `${text}\n${currentText}` : currentText;
                  // parse blockquote lines as top level tokens
                  // merge paragraphs if this is a continuation
                  const top = this.lexer.state.top;
                  this.lexer.state.top = true;
                  this.lexer.blockTokens(currentText, tokens, true);
                  this.lexer.state.top = top;
                  // if there is no continuation then we are done
                  if (lines.length === 0) {
                      break;
                  }
                  const lastToken = tokens.at(-1);
                  if (lastToken?.type === 'code') {
                      // blockquote continuation cannot be preceded by a code block
                      break;
                  }
                  else if (lastToken?.type === 'blockquote') {
                      // include continuation in nested blockquote
                      const oldToken = lastToken;
                      const newText = oldToken.raw + '\n' + lines.join('\n');
                      const newToken = this.blockquote(newText);
                      tokens[tokens.length - 1] = newToken;
                      raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
                      text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
                      break;
                  }
                  else if (lastToken?.type === 'list') {
                      // include continuation in nested list
                      const oldToken = lastToken;
                      const newText = oldToken.raw + '\n' + lines.join('\n');
                      const newToken = this.list(newText);
                      tokens[tokens.length - 1] = newToken;
                      raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
                      text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
                      lines = newText.substring(tokens.at(-1).raw.length).split('\n');
                      continue;
                  }
              }
              return {
                  type: 'blockquote',
                  raw,
                  tokens,
                  text,
              };
          }
      }
      list(src) {
          let cap = this.rules.block.list.exec(src);
          if (cap) {
              let bull = cap[1].trim();
              const isordered = bull.length > 1;
              const list = {
                  type: 'list',
                  raw: '',
                  ordered: isordered,
                  start: isordered ? +bull.slice(0, -1) : '',
                  loose: false,
                  items: [],
              };
              bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
              if (this.options.pedantic) {
                  bull = isordered ? bull : '[*+-]';
              }
              // Get next list item
              const itemRegex = this.rules.other.listItemRegex(bull);
              let endsWithBlankLine = false;
              // Check if current bullet point can start a new List Item
              while (src) {
                  let endEarly = false;
                  let raw = '';
                  let itemContents = '';
                  if (!(cap = itemRegex.exec(src))) {
                      break;
                  }
                  if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
                      break;
                  }
                  raw = cap[0];
                  src = src.substring(raw.length);
                  let line = cap[2].split('\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));
                  let nextLine = src.split('\n', 1)[0];
                  let blankLine = !line.trim();
                  let indent = 0;
                  if (this.options.pedantic) {
                      indent = 2;
                      itemContents = line.trimStart();
                  }
                  else if (blankLine) {
                      indent = cap[1].length + 1;
                  }
                  else {
                      indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char
                      indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                      itemContents = line.slice(indent);
                      indent += cap[1].length;
                  }
                  if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line
                      raw += nextLine + '\n';
                      src = src.substring(nextLine.length + 1);
                      endEarly = true;
                  }
                  if (!endEarly) {
                      const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
                      const hrRegex = this.rules.other.hrRegex(indent);
                      const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
                      const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
                      const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
                      // Check if following lines should be included in List Item
                      while (src) {
                          const rawLine = src.split('\n', 1)[0];
                          let nextLineWithoutTabs;
                          nextLine = rawLine;
                          // Re-align to follow commonmark nesting rules
                          if (this.options.pedantic) {
                              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');
                              nextLineWithoutTabs = nextLine;
                          }
                          else {
                              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');
                          }
                          // End list item if found code fences
                          if (fencesBeginRegex.test(nextLine)) {
                              break;
                          }
                          // End list item if found start of new heading
                          if (headingBeginRegex.test(nextLine)) {
                              break;
                          }
                          // End list item if found start of html block
                          if (htmlBeginRegex.test(nextLine)) {
                              break;
                          }
                          // End list item if found start of new bullet
                          if (nextBulletRegex.test(nextLine)) {
                              break;
                          }
                          // Horizontal rule found
                          if (hrRegex.test(nextLine)) {
                              break;
                          }
                          if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible
                              itemContents += '\n' + nextLineWithoutTabs.slice(indent);
                          }
                          else {
                              // not enough indentation
                              if (blankLine) {
                                  break;
                              }
                              // paragraph continuation unless last line was a different block level element
                              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block
                                  break;
                              }
                              if (fencesBeginRegex.test(line)) {
                                  break;
                              }
                              if (headingBeginRegex.test(line)) {
                                  break;
                              }
                              if (hrRegex.test(line)) {
                                  break;
                              }
                              itemContents += '\n' + nextLine;
                          }
                          if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                              blankLine = true;
                          }
                          raw += rawLine + '\n';
                          src = src.substring(rawLine.length + 1);
                          line = nextLineWithoutTabs.slice(indent);
                      }
                  }
                  if (!list.loose) {
                      // If the previous item ended with a blank line, the list is loose
                      if (endsWithBlankLine) {
                          list.loose = true;
                      }
                      else if (this.rules.other.doubleBlankLine.test(raw)) {
                          endsWithBlankLine = true;
                      }
                  }
                  let istask = null;
                  let ischecked;
                  // Check for task list items
                  if (this.options.gfm) {
                      istask = this.rules.other.listIsTask.exec(itemContents);
                      if (istask) {
                          ischecked = istask[0] !== '[ ] ';
                          itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');
                      }
                  }
                  list.items.push({
                      type: 'list_item',
                      raw,
                      task: !!istask,
                      checked: ischecked,
                      loose: false,
                      text: itemContents,
                      tokens: [],
                  });
                  list.raw += raw;
              }
              // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
              const lastItem = list.items.at(-1);
              if (lastItem) {
                  lastItem.raw = lastItem.raw.trimEnd();
                  lastItem.text = lastItem.text.trimEnd();
              }
              else {
                  // not a list since there were no items
                  return;
              }
              list.raw = list.raw.trimEnd();
              // Item child tokens handled here at end because we needed to have the final item to trim it first
              for (let i = 0; i < list.items.length; i++) {
                  this.lexer.state.top = false;
                  list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                  if (!list.loose) {
                      // Check if list should be loose
                      const spacers = list.items[i].tokens.filter(t => t.type === 'space');
                      const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));
                      list.loose = hasMultipleLineBreaks;
                  }
              }
              // Set all items to loose if list is loose
              if (list.loose) {
                  for (let i = 0; i < list.items.length; i++) {
                      list.items[i].loose = true;
                  }
              }
              return list;
          }
      }
      html(src) {
          const cap = this.rules.block.html.exec(src);
          if (cap) {
              const token = {
                  type: 'html',
                  block: true,
                  raw: cap[0],
                  pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                  text: cap[0],
              };
              return token;
          }
      }
      def(src) {
          const cap = this.rules.block.def.exec(src);
          if (cap) {
              const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');
              const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
              const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
              return {
                  type: 'def',
                  tag,
                  raw: cap[0],
                  href,
                  title,
              };
          }
      }
      table(src) {
          const cap = this.rules.block.table.exec(src);
          if (!cap) {
              return;
          }
          if (!this.rules.other.tableDelimiter.test(cap[2])) {
              // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
              return;
          }
          const headers = splitCells(cap[1]);
          const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');
          const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\n') : [];
          const item = {
              type: 'table',
              raw: cap[0],
              header: [],
              align: [],
              rows: [],
          };
          if (headers.length !== aligns.length) {
              // header and align columns must be equal, rows can be different.
              return;
          }
          for (const align of aligns) {
              if (this.rules.other.tableAlignRight.test(align)) {
                  item.align.push('right');
              }
              else if (this.rules.other.tableAlignCenter.test(align)) {
                  item.align.push('center');
              }
              else if (this.rules.other.tableAlignLeft.test(align)) {
                  item.align.push('left');
              }
              else {
                  item.align.push(null);
              }
          }
          for (let i = 0; i < headers.length; i++) {
              item.header.push({
                  text: headers[i],
                  tokens: this.lexer.inline(headers[i]),
                  header: true,
                  align: item.align[i],
              });
          }
          for (const row of rows) {
              item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
                  return {
                      text: cell,
                      tokens: this.lexer.inline(cell),
                      header: false,
                      align: item.align[i],
                  };
              }));
          }
          return item;
      }
      lheading(src) {
          const cap = this.rules.block.lheading.exec(src);
          if (cap) {
              return {
                  type: 'heading',
                  raw: cap[0],
                  depth: cap[2].charAt(0) === '=' ? 1 : 2,
                  text: cap[1],
                  tokens: this.lexer.inline(cap[1]),
              };
          }
      }
      paragraph(src) {
          const cap = this.rules.block.paragraph.exec(src);
          if (cap) {
              const text = cap[1].charAt(cap[1].length - 1) === '\n'
                  ? cap[1].slice(0, -1)
                  : cap[1];
              return {
                  type: 'paragraph',
                  raw: cap[0],
                  text,
                  tokens: this.lexer.inline(text),
              };
          }
      }
      text(src) {
          const cap = this.rules.block.text.exec(src);
          if (cap) {
              return {
                  type: 'text',
                  raw: cap[0],
                  text: cap[0],
                  tokens: this.lexer.inline(cap[0]),
              };
          }
      }
      escape(src) {
          const cap = this.rules.inline.escape.exec(src);
          if (cap) {
              return {
                  type: 'escape',
                  raw: cap[0],
                  text: cap[1],
              };
          }
      }
      tag(src) {
          const cap = this.rules.inline.tag.exec(src);
          if (cap) {
              if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
                  this.lexer.state.inLink = true;
              }
              else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
                  this.lexer.state.inLink = false;
              }
              if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
                  this.lexer.state.inRawBlock = true;
              }
              else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
                  this.lexer.state.inRawBlock = false;
              }
              return {
                  type: 'html',
                  raw: cap[0],
                  inLink: this.lexer.state.inLink,
                  inRawBlock: this.lexer.state.inRawBlock,
                  block: false,
                  text: cap[0],
              };
          }
      }
      link(src) {
          const cap = this.rules.inline.link.exec(src);
          if (cap) {
              const trimmedUrl = cap[2].trim();
              if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
                  // commonmark requires matching angle brackets
                  if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {
                      return;
                  }
                  // ending angle bracket cannot be escaped
                  const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                  if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                      return;
                  }
              }
              else {
                  // find closing parenthesis
                  const lastParenIndex = findClosingBracket(cap[2], '()');
                  if (lastParenIndex === -2) {
                      // more open parens than closed
                      return;
                  }
                  if (lastParenIndex > -1) {
                      const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                      const linkLen = start + cap[1].length + lastParenIndex;
                      cap[2] = cap[2].substring(0, lastParenIndex);
                      cap[0] = cap[0].substring(0, linkLen).trim();
                      cap[3] = '';
                  }
              }
              let href = cap[2];
              let title = '';
              if (this.options.pedantic) {
                  // split pedantic href and title
                  const link = this.rules.other.pedanticHrefTitle.exec(href);
                  if (link) {
                      href = link[1];
                      title = link[3];
                  }
              }
              else {
                  title = cap[3] ? cap[3].slice(1, -1) : '';
              }
              href = href.trim();
              if (this.rules.other.startAngleBracket.test(href)) {
                  if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {
                      // pedantic allows starting angle bracket without ending angle bracket
                      href = href.slice(1);
                  }
                  else {
                      href = href.slice(1, -1);
                  }
              }
              return outputLink(cap, {
                  href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                  title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,
              }, cap[0], this.lexer, this.rules);
          }
      }
      reflink(src, links) {
          let cap;
          if ((cap = this.rules.inline.reflink.exec(src))
              || (cap = this.rules.inline.nolink.exec(src))) {
              const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');
              const link = links[linkString.toLowerCase()];
              if (!link) {
                  const text = cap[0].charAt(0);
                  return {
                      type: 'text',
                      raw: text,
                      text,
                  };
              }
              return outputLink(cap, link, cap[0], this.lexer, this.rules);
          }
      }
      emStrong(src, maskedSrc, prevChar = '') {
          let match = this.rules.inline.emStrongLDelim.exec(src);
          if (!match)
              return;
          // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
          if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
              return;
          const nextChar = match[1] || match[2] || '';
          if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
              // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
              const lLength = [...match[0]].length - 1;
              let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
              const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
              endReg.lastIndex = 0;
              // Clip maskedSrc to same section of string as src (move to lexer?)
              maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
              while ((match = endReg.exec(maskedSrc)) != null) {
                  rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                  if (!rDelim)
                      continue; // skip single * in __abc*abc__
                  rLength = [...rDelim].length;
                  if (match[3] || match[4]) { // found another Left Delim
                      delimTotal += rLength;
                      continue;
                  }
                  else if (match[5] || match[6]) { // either Left or Right Delim
                      if (lLength % 3 && !((lLength + rLength) % 3)) {
                          midDelimTotal += rLength;
                          continue; // CommonMark Emphasis Rules 9-10
                      }
                  }
                  delimTotal -= rLength;
                  if (delimTotal > 0)
                      continue; // Haven't found enough closing delimiters
                  // Remove extra characters. *a*** -> *a*
                  rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                  // char length can be >1 for unicode characters;
                  const lastCharLength = [...match[0]][0].length;
                  const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                  // Create `em` if smallest delimiter has odd char count. *a***
                  if (Math.min(lLength, rLength) % 2) {
                      const text = raw.slice(1, -1);
                      return {
                          type: 'em',
                          raw,
                          text,
                          tokens: this.lexer.inlineTokens(text),
                      };
                  }
                  // Create 'strong' if smallest delimiter has even char count. **a***
                  const text = raw.slice(2, -2);
                  return {
                      type: 'strong',
                      raw,
                      text,
                      tokens: this.lexer.inlineTokens(text),
                  };
              }
          }
      }
      codespan(src) {
          const cap = this.rules.inline.code.exec(src);
          if (cap) {
              let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');
              const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
              const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
              if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                  text = text.substring(1, text.length - 1);
              }
              return {
                  type: 'codespan',
                  raw: cap[0],
                  text,
              };
          }
      }
      br(src) {
          const cap = this.rules.inline.br.exec(src);
          if (cap) {
              return {
                  type: 'br',
                  raw: cap[0],
              };
          }
      }
      del(src) {
          const cap = this.rules.inline.del.exec(src);
          if (cap) {
              return {
                  type: 'del',
                  raw: cap[0],
                  text: cap[2],
                  tokens: this.lexer.inlineTokens(cap[2]),
              };
          }
      }
      autolink(src) {
          const cap = this.rules.inline.autolink.exec(src);
          if (cap) {
              let text, href;
              if (cap[2] === '@') {
                  text = cap[1];
                  href = 'mailto:' + text;
              }
              else {
                  text = cap[1];
                  href = text;
              }
              return {
                  type: 'link',
                  raw: cap[0],
                  text,
                  href,
                  tokens: [
                      {
                          type: 'text',
                          raw: text,
                          text,
                      },
                  ],
              };
          }
      }
      url(src) {
          let cap;
          if (cap = this.rules.inline.url.exec(src)) {
              let text, href;
              if (cap[2] === '@') {
                  text = cap[0];
                  href = 'mailto:' + text;
              }
              else {
                  // do extended autolink path validation
                  let prevCapZero;
                  do {
                      prevCapZero = cap[0];
                      cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                  } while (prevCapZero !== cap[0]);
                  text = cap[0];
                  if (cap[1] === 'www.') {
                      href = 'http://' + cap[0];
                  }
                  else {
                      href = cap[0];
                  }
              }
              return {
                  type: 'link',
                  raw: cap[0],
                  text,
                  href,
                  tokens: [
                      {
                          type: 'text',
                          raw: text,
                          text,
                      },
                  ],
              };
          }
      }
      inlineText(src) {
          const cap = this.rules.inline.text.exec(src);
          if (cap) {
              const escaped = this.lexer.state.inRawBlock;
              return {
                  type: 'text',
                  raw: cap[0],
                  text: cap[0],
                  escaped,
              };
          }
      }
  }

  /**
   * Block Lexer
   */
  class _Lexer {
      tokens;
      options;
      state;
      tokenizer;
      inlineQueue;
      constructor(options) {
          // TokenList cannot be created in one go
          this.tokens = [];
          this.tokens.links = Object.create(null);
          this.options = options || _defaults;
          this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          this.tokenizer.lexer = this;
          this.inlineQueue = [];
          this.state = {
              inLink: false,
              inRawBlock: false,
              top: true,
          };
          const rules = {
              other,
              block: block.normal,
              inline: inline.normal,
          };
          if (this.options.pedantic) {
              rules.block = block.pedantic;
              rules.inline = inline.pedantic;
          }
          else if (this.options.gfm) {
              rules.block = block.gfm;
              if (this.options.breaks) {
                  rules.inline = inline.breaks;
              }
              else {
                  rules.inline = inline.gfm;
              }
          }
          this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
          return {
              block,
              inline,
          };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options) {
          const lexer = new _Lexer(options);
          return lexer.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
          const lexer = new _Lexer(options);
          return lexer.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
          src = src.replace(other.carriageReturn, '\n');
          this.blockTokens(src, this.tokens);
          for (let i = 0; i < this.inlineQueue.length; i++) {
              const next = this.inlineQueue[i];
              this.inlineTokens(next.src, next.tokens);
          }
          this.inlineQueue = [];
          return this.tokens;
      }
      blockTokens(src, tokens = [], lastParagraphClipped = false) {
          if (this.options.pedantic) {
              src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');
          }
          while (src) {
              let token;
              if (this.options.extensions?.block?.some((extTokenizer) => {
                  if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                      src = src.substring(token.raw.length);
                      tokens.push(token);
                      return true;
                  }
                  return false;
              })) {
                  continue;
              }
              // newline
              if (token = this.tokenizer.space(src)) {
                  src = src.substring(token.raw.length);
                  const lastToken = tokens.at(-1);
                  if (token.raw.length === 1 && lastToken !== undefined) {
                      // if there's a single \n as a spacer, it's terminating the last line,
                      // so move it there so that we don't get unnecessary paragraph tags
                      lastToken.raw += '\n';
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // code
              if (token = this.tokenizer.code(src)) {
                  src = src.substring(token.raw.length);
                  const lastToken = tokens.at(-1);
                  // An indented code block cannot interrupt a paragraph.
                  if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.text;
                      this.inlineQueue.at(-1).src = lastToken.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // fences
              if (token = this.tokenizer.fences(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // heading
              if (token = this.tokenizer.heading(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // hr
              if (token = this.tokenizer.hr(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // blockquote
              if (token = this.tokenizer.blockquote(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // list
              if (token = this.tokenizer.list(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // html
              if (token = this.tokenizer.html(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // def
              if (token = this.tokenizer.def(src)) {
                  src = src.substring(token.raw.length);
                  const lastToken = tokens.at(-1);
                  if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.raw;
                      this.inlineQueue.at(-1).src = lastToken.text;
                  }
                  else if (!this.tokens.links[token.tag]) {
                      this.tokens.links[token.tag] = {
                          href: token.href,
                          title: token.title,
                      };
                  }
                  continue;
              }
              // table (gfm)
              if (token = this.tokenizer.table(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // lheading
              if (token = this.tokenizer.lheading(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // top-level paragraph
              // prevent paragraph consuming extensions by clipping 'src' to extension start
              let cutSrc = src;
              if (this.options.extensions?.startBlock) {
                  let startIndex = Infinity;
                  const tempSrc = src.slice(1);
                  let tempStart;
                  this.options.extensions.startBlock.forEach((getStartIndex) => {
                      tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                      if (typeof tempStart === 'number' && tempStart >= 0) {
                          startIndex = Math.min(startIndex, tempStart);
                      }
                  });
                  if (startIndex < Infinity && startIndex >= 0) {
                      cutSrc = src.substring(0, startIndex + 1);
                  }
              }
              if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                  const lastToken = tokens.at(-1);
                  if (lastParagraphClipped && lastToken?.type === 'paragraph') {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.text;
                      this.inlineQueue.pop();
                      this.inlineQueue.at(-1).src = lastToken.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  lastParagraphClipped = cutSrc.length !== src.length;
                  src = src.substring(token.raw.length);
                  continue;
              }
              // text
              if (token = this.tokenizer.text(src)) {
                  src = src.substring(token.raw.length);
                  const lastToken = tokens.at(-1);
                  if (lastToken?.type === 'text') {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.text;
                      this.inlineQueue.pop();
                      this.inlineQueue.at(-1).src = lastToken.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              if (src) {
                  const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                  if (this.options.silent) {
                      console.error(errMsg);
                      break;
                  }
                  else {
                      throw new Error(errMsg);
                  }
              }
          }
          this.state.top = true;
          return tokens;
      }
      inline(src, tokens = []) {
          this.inlineQueue.push({ src, tokens });
          return tokens;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
          // String with links masked to avoid interference with em and strong
          let maskedSrc = src;
          let match = null;
          // Mask out reflinks
          if (this.tokens.links) {
              const links = Object.keys(this.tokens.links);
              if (links.length > 0) {
                  while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                      if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                          maskedSrc = maskedSrc.slice(0, match.index)
                              + '[' + 'a'.repeat(match[0].length - 2) + ']'
                              + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                      }
                  }
              }
          }
          // Mask out escaped characters
          while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
          }
          // Mask out other blocks
          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }
          let keepPrevChar = false;
          let prevChar = '';
          while (src) {
              if (!keepPrevChar) {
                  prevChar = '';
              }
              keepPrevChar = false;
              let token;
              // extensions
              if (this.options.extensions?.inline?.some((extTokenizer) => {
                  if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                      src = src.substring(token.raw.length);
                      tokens.push(token);
                      return true;
                  }
                  return false;
              })) {
                  continue;
              }
              // escape
              if (token = this.tokenizer.escape(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // tag
              if (token = this.tokenizer.tag(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // link
              if (token = this.tokenizer.link(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // reflink, nolink
              if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                  src = src.substring(token.raw.length);
                  const lastToken = tokens.at(-1);
                  if (token.type === 'text' && lastToken?.type === 'text') {
                      lastToken.raw += token.raw;
                      lastToken.text += token.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // em & strong
              if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // code
              if (token = this.tokenizer.codespan(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // br
              if (token = this.tokenizer.br(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // del (gfm)
              if (token = this.tokenizer.del(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // autolink
              if (token = this.tokenizer.autolink(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // url (gfm)
              if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // text
              // prevent inlineText consuming extensions by clipping 'src' to extension start
              let cutSrc = src;
              if (this.options.extensions?.startInline) {
                  let startIndex = Infinity;
                  const tempSrc = src.slice(1);
                  let tempStart;
                  this.options.extensions.startInline.forEach((getStartIndex) => {
                      tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                      if (typeof tempStart === 'number' && tempStart >= 0) {
                          startIndex = Math.min(startIndex, tempStart);
                      }
                  });
                  if (startIndex < Infinity && startIndex >= 0) {
                      cutSrc = src.substring(0, startIndex + 1);
                  }
              }
              if (token = this.tokenizer.inlineText(cutSrc)) {
                  src = src.substring(token.raw.length);
                  if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
                      prevChar = token.raw.slice(-1);
                  }
                  keepPrevChar = true;
                  const lastToken = tokens.at(-1);
                  if (lastToken?.type === 'text') {
                      lastToken.raw += token.raw;
                      lastToken.text += token.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              if (src) {
                  const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                  if (this.options.silent) {
                      console.error(errMsg);
                      break;
                  }
                  else {
                      throw new Error(errMsg);
                  }
              }
          }
          return tokens;
      }
  }

  /**
   * Renderer
   */
  class _Renderer {
      options;
      parser; // set by the parser
      constructor(options) {
          this.options = options || _defaults;
      }
      space(token) {
          return '';
      }
      code({ text, lang, escaped }) {
          const langString = (lang || '').match(other.notSpaceStart)?.[0];
          const code = text.replace(other.endingNewline, '') + '\n';
          if (!langString) {
              return '<pre><code>'
                  + (escaped ? code : escape(code, true))
                  + '</code></pre>\n';
          }
          return '<pre><code class="language-'
              + escape(langString)
              + '">'
              + (escaped ? code : escape(code, true))
              + '</code></pre>\n';
      }
      blockquote({ tokens }) {
          const body = this.parser.parse(tokens);
          return `<blockquote>\n${body}</blockquote>\n`;
      }
      html({ text }) {
          return text;
      }
      heading({ tokens, depth }) {
          return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;
      }
      hr(token) {
          return '<hr>\n';
      }
      list(token) {
          const ordered = token.ordered;
          const start = token.start;
          let body = '';
          for (let j = 0; j < token.items.length; j++) {
              const item = token.items[j];
              body += this.listitem(item);
          }
          const type = ordered ? 'ol' : 'ul';
          const startAttr = (ordered && start !== 1) ? (' start="' + start + '"') : '';
          return '<' + type + startAttr + '>\n' + body + '</' + type + '>\n';
      }
      listitem(item) {
          let itemBody = '';
          if (item.task) {
              const checkbox = this.checkbox({ checked: !!item.checked });
              if (item.loose) {
                  if (item.tokens[0]?.type === 'paragraph') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                          item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);
                          item.tokens[0].tokens[0].escaped = true;
                      }
                  }
                  else {
                      item.tokens.unshift({
                          type: 'text',
                          raw: checkbox + ' ',
                          text: checkbox + ' ',
                          escaped: true,
                      });
                  }
              }
              else {
                  itemBody += checkbox + ' ';
              }
          }
          itemBody += this.parser.parse(item.tokens, !!item.loose);
          return `<li>${itemBody}</li>\n`;
      }
      checkbox({ checked }) {
          return '<input '
              + (checked ? 'checked="" ' : '')
              + 'disabled="" type="checkbox">';
      }
      paragraph({ tokens }) {
          return `<p>${this.parser.parseInline(tokens)}</p>\n`;
      }
      table(token) {
          let header = '';
          // header
          let cell = '';
          for (let j = 0; j < token.header.length; j++) {
              cell += this.tablecell(token.header[j]);
          }
          header += this.tablerow({ text: cell });
          let body = '';
          for (let j = 0; j < token.rows.length; j++) {
              const row = token.rows[j];
              cell = '';
              for (let k = 0; k < row.length; k++) {
                  cell += this.tablecell(row[k]);
              }
              body += this.tablerow({ text: cell });
          }
          if (body)
              body = `<tbody>${body}</tbody>`;
          return '<table>\n'
              + '<thead>\n'
              + header
              + '</thead>\n'
              + body
              + '</table>\n';
      }
      tablerow({ text }) {
          return `<tr>\n${text}</tr>\n`;
      }
      tablecell(token) {
          const content = this.parser.parseInline(token.tokens);
          const type = token.header ? 'th' : 'td';
          const tag = token.align
              ? `<${type} align="${token.align}">`
              : `<${type}>`;
          return tag + content + `</${type}>\n`;
      }
      /**
       * span level renderer
       */
      strong({ tokens }) {
          return `<strong>${this.parser.parseInline(tokens)}</strong>`;
      }
      em({ tokens }) {
          return `<em>${this.parser.parseInline(tokens)}</em>`;
      }
      codespan({ text }) {
          return `<code>${escape(text, true)}</code>`;
      }
      br(token) {
          return '<br>';
      }
      del({ tokens }) {
          return `<del>${this.parser.parseInline(tokens)}</del>`;
      }
      link({ href, title, tokens }) {
          const text = this.parser.parseInline(tokens);
          const cleanHref = cleanUrl(href);
          if (cleanHref === null) {
              return text;
          }
          href = cleanHref;
          let out = '<a href="' + href + '"';
          if (title) {
              out += ' title="' + (escape(title)) + '"';
          }
          out += '>' + text + '</a>';
          return out;
      }
      image({ href, title, text, tokens }) {
          if (tokens) {
              text = this.parser.parseInline(tokens, this.parser.textRenderer);
          }
          const cleanHref = cleanUrl(href);
          if (cleanHref === null) {
              return escape(text);
          }
          href = cleanHref;
          let out = `<img src="${href}" alt="${text}"`;
          if (title) {
              out += ` title="${escape(title)}"`;
          }
          out += '>';
          return out;
      }
      text(token) {
          return 'tokens' in token && token.tokens
              ? this.parser.parseInline(token.tokens)
              : ('escaped' in token && token.escaped ? token.text : escape(token.text));
      }
  }

  /**
   * TextRenderer
   * returns only the textual part of the token
   */
  class _TextRenderer {
      // no need for block level renderers
      strong({ text }) {
          return text;
      }
      em({ text }) {
          return text;
      }
      codespan({ text }) {
          return text;
      }
      del({ text }) {
          return text;
      }
      html({ text }) {
          return text;
      }
      text({ text }) {
          return text;
      }
      link({ text }) {
          return '' + text;
      }
      image({ text }) {
          return '' + text;
      }
      br() {
          return '';
      }
  }

  /**
   * Parsing & Compiling
   */
  class _Parser {
      options;
      renderer;
      textRenderer;
      constructor(options) {
          this.options = options || _defaults;
          this.options.renderer = this.options.renderer || new _Renderer();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.renderer.parser = this;
          this.textRenderer = new _TextRenderer();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
          const parser = new _Parser(options);
          return parser.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
          const parser = new _Parser(options);
          return parser.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
          let out = '';
          for (let i = 0; i < tokens.length; i++) {
              const anyToken = tokens[i];
              // Run any renderer extensions
              if (this.options.extensions?.renderers?.[anyToken.type]) {
                  const genericToken = anyToken;
                  const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                  if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                      out += ret || '';
                      continue;
                  }
              }
              const token = anyToken;
              switch (token.type) {
                  case 'space': {
                      out += this.renderer.space(token);
                      continue;
                  }
                  case 'hr': {
                      out += this.renderer.hr(token);
                      continue;
                  }
                  case 'heading': {
                      out += this.renderer.heading(token);
                      continue;
                  }
                  case 'code': {
                      out += this.renderer.code(token);
                      continue;
                  }
                  case 'table': {
                      out += this.renderer.table(token);
                      continue;
                  }
                  case 'blockquote': {
                      out += this.renderer.blockquote(token);
                      continue;
                  }
                  case 'list': {
                      out += this.renderer.list(token);
                      continue;
                  }
                  case 'html': {
                      out += this.renderer.html(token);
                      continue;
                  }
                  case 'paragraph': {
                      out += this.renderer.paragraph(token);
                      continue;
                  }
                  case 'text': {
                      let textToken = token;
                      let body = this.renderer.text(textToken);
                      while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                          textToken = tokens[++i];
                          body += '\n' + this.renderer.text(textToken);
                      }
                      if (top) {
                          out += this.renderer.paragraph({
                              type: 'paragraph',
                              raw: body,
                              text: body,
                              tokens: [{ type: 'text', raw: body, text: body, escaped: true }],
                          });
                      }
                      else {
                          out += body;
                      }
                      continue;
                  }
                  default: {
                      const errMsg = 'Token with "' + token.type + '" type was not found.';
                      if (this.options.silent) {
                          console.error(errMsg);
                          return '';
                      }
                      else {
                          throw new Error(errMsg);
                      }
                  }
              }
          }
          return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer = this.renderer) {
          let out = '';
          for (let i = 0; i < tokens.length; i++) {
              const anyToken = tokens[i];
              // Run any renderer extensions
              if (this.options.extensions?.renderers?.[anyToken.type]) {
                  const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
                  if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {
                      out += ret || '';
                      continue;
                  }
              }
              const token = anyToken;
              switch (token.type) {
                  case 'escape': {
                      out += renderer.text(token);
                      break;
                  }
                  case 'html': {
                      out += renderer.html(token);
                      break;
                  }
                  case 'link': {
                      out += renderer.link(token);
                      break;
                  }
                  case 'image': {
                      out += renderer.image(token);
                      break;
                  }
                  case 'strong': {
                      out += renderer.strong(token);
                      break;
                  }
                  case 'em': {
                      out += renderer.em(token);
                      break;
                  }
                  case 'codespan': {
                      out += renderer.codespan(token);
                      break;
                  }
                  case 'br': {
                      out += renderer.br(token);
                      break;
                  }
                  case 'del': {
                      out += renderer.del(token);
                      break;
                  }
                  case 'text': {
                      out += renderer.text(token);
                      break;
                  }
                  default: {
                      const errMsg = 'Token with "' + token.type + '" type was not found.';
                      if (this.options.silent) {
                          console.error(errMsg);
                          return '';
                      }
                      else {
                          throw new Error(errMsg);
                      }
                  }
              }
          }
          return out;
      }
  }

  class _Hooks {
      options;
      block;
      constructor(options) {
          this.options = options || _defaults;
      }
      static passThroughHooks = new Set([
          'preprocess',
          'postprocess',
          'processAllTokens',
      ]);
      /**
       * Process markdown before marked
       */
      preprocess(markdown) {
          return markdown;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(html) {
          return html;
      }
      /**
       * Process all tokens before walk tokens
       */
      processAllTokens(tokens) {
          return tokens;
      }
      /**
       * Provide function to tokenize markdown
       */
      provideLexer() {
          return this.block ? _Lexer.lex : _Lexer.lexInline;
      }
      /**
       * Provide function to parse tokens
       */
      provideParser() {
          return this.block ? _Parser.parse : _Parser.parseInline;
      }
  }

  class Marked {
      defaults = _getDefaults();
      options = this.setOptions;
      parse = this.parseMarkdown(true);
      parseInline = this.parseMarkdown(false);
      Parser = _Parser;
      Renderer = _Renderer;
      TextRenderer = _TextRenderer;
      Lexer = _Lexer;
      Tokenizer = _Tokenizer;
      Hooks = _Hooks;
      constructor(...args) {
          this.use(...args);
      }
      /**
       * Run callback for every token
       */
      walkTokens(tokens, callback) {
          let values = [];
          for (const token of tokens) {
              values = values.concat(callback.call(this, token));
              switch (token.type) {
                  case 'table': {
                      const tableToken = token;
                      for (const cell of tableToken.header) {
                          values = values.concat(this.walkTokens(cell.tokens, callback));
                      }
                      for (const row of tableToken.rows) {
                          for (const cell of row) {
                              values = values.concat(this.walkTokens(cell.tokens, callback));
                          }
                      }
                      break;
                  }
                  case 'list': {
                      const listToken = token;
                      values = values.concat(this.walkTokens(listToken.items, callback));
                      break;
                  }
                  default: {
                      const genericToken = token;
                      if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                          this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                              const tokens = genericToken[childTokens].flat(Infinity);
                              values = values.concat(this.walkTokens(tokens, callback));
                          });
                      }
                      else if (genericToken.tokens) {
                          values = values.concat(this.walkTokens(genericToken.tokens, callback));
                      }
                  }
              }
          }
          return values;
      }
      use(...args) {
          const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
          args.forEach((pack) => {
              // copy options to new object
              const opts = { ...pack };
              // set async to true if it was set to true before
              opts.async = this.defaults.async || opts.async || false;
              // ==-- Parse "addon" extensions --== //
              if (pack.extensions) {
                  pack.extensions.forEach((ext) => {
                      if (!ext.name) {
                          throw new Error('extension name required');
                      }
                      if ('renderer' in ext) { // Renderer extensions
                          const prevRenderer = extensions.renderers[ext.name];
                          if (prevRenderer) {
                              // Replace extension with func to run new extension but fall back if false
                              extensions.renderers[ext.name] = function (...args) {
                                  let ret = ext.renderer.apply(this, args);
                                  if (ret === false) {
                                      ret = prevRenderer.apply(this, args);
                                  }
                                  return ret;
                              };
                          }
                          else {
                              extensions.renderers[ext.name] = ext.renderer;
                          }
                      }
                      if ('tokenizer' in ext) { // Tokenizer Extensions
                          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                              throw new Error("extension level must be 'block' or 'inline'");
                          }
                          const extLevel = extensions[ext.level];
                          if (extLevel) {
                              extLevel.unshift(ext.tokenizer);
                          }
                          else {
                              extensions[ext.level] = [ext.tokenizer];
                          }
                          if (ext.start) { // Function to check for start of token
                              if (ext.level === 'block') {
                                  if (extensions.startBlock) {
                                      extensions.startBlock.push(ext.start);
                                  }
                                  else {
                                      extensions.startBlock = [ext.start];
                                  }
                              }
                              else if (ext.level === 'inline') {
                                  if (extensions.startInline) {
                                      extensions.startInline.push(ext.start);
                                  }
                                  else {
                                      extensions.startInline = [ext.start];
                                  }
                              }
                          }
                      }
                      if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
                          extensions.childTokens[ext.name] = ext.childTokens;
                      }
                  });
                  opts.extensions = extensions;
              }
              // ==-- Parse "overwrite" extensions --== //
              if (pack.renderer) {
                  const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                  for (const prop in pack.renderer) {
                      if (!(prop in renderer)) {
                          throw new Error(`renderer '${prop}' does not exist`);
                      }
                      if (['options', 'parser'].includes(prop)) {
                          // ignore options property
                          continue;
                      }
                      const rendererProp = prop;
                      const rendererFunc = pack.renderer[rendererProp];
                      const prevRenderer = renderer[rendererProp];
                      // Replace renderer with func to run extension, but fall back if false
                      renderer[rendererProp] = (...args) => {
                          let ret = rendererFunc.apply(renderer, args);
                          if (ret === false) {
                              ret = prevRenderer.apply(renderer, args);
                          }
                          return ret || '';
                      };
                  }
                  opts.renderer = renderer;
              }
              if (pack.tokenizer) {
                  const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                  for (const prop in pack.tokenizer) {
                      if (!(prop in tokenizer)) {
                          throw new Error(`tokenizer '${prop}' does not exist`);
                      }
                      if (['options', 'rules', 'lexer'].includes(prop)) {
                          // ignore options, rules, and lexer properties
                          continue;
                      }
                      const tokenizerProp = prop;
                      const tokenizerFunc = pack.tokenizer[tokenizerProp];
                      const prevTokenizer = tokenizer[tokenizerProp];
                      // Replace tokenizer with func to run extension, but fall back if false
                      // @ts-expect-error cannot type tokenizer function dynamically
                      tokenizer[tokenizerProp] = (...args) => {
                          let ret = tokenizerFunc.apply(tokenizer, args);
                          if (ret === false) {
                              ret = prevTokenizer.apply(tokenizer, args);
                          }
                          return ret;
                      };
                  }
                  opts.tokenizer = tokenizer;
              }
              // ==-- Parse Hooks extensions --== //
              if (pack.hooks) {
                  const hooks = this.defaults.hooks || new _Hooks();
                  for (const prop in pack.hooks) {
                      if (!(prop in hooks)) {
                          throw new Error(`hook '${prop}' does not exist`);
                      }
                      if (['options', 'block'].includes(prop)) {
                          // ignore options and block properties
                          continue;
                      }
                      const hooksProp = prop;
                      const hooksFunc = pack.hooks[hooksProp];
                      const prevHook = hooks[hooksProp];
                      if (_Hooks.passThroughHooks.has(prop)) {
                          // @ts-expect-error cannot type hook function dynamically
                          hooks[hooksProp] = (arg) => {
                              if (this.defaults.async) {
                                  return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                                      return prevHook.call(hooks, ret);
                                  });
                              }
                              const ret = hooksFunc.call(hooks, arg);
                              return prevHook.call(hooks, ret);
                          };
                      }
                      else {
                          // @ts-expect-error cannot type hook function dynamically
                          hooks[hooksProp] = (...args) => {
                              let ret = hooksFunc.apply(hooks, args);
                              if (ret === false) {
                                  ret = prevHook.apply(hooks, args);
                              }
                              return ret;
                          };
                      }
                  }
                  opts.hooks = hooks;
              }
              // ==-- Parse WalkTokens extensions --== //
              if (pack.walkTokens) {
                  const walkTokens = this.defaults.walkTokens;
                  const packWalktokens = pack.walkTokens;
                  opts.walkTokens = function (token) {
                      let values = [];
                      values.push(packWalktokens.call(this, token));
                      if (walkTokens) {
                          values = values.concat(walkTokens.call(this, token));
                      }
                      return values;
                  };
              }
              this.defaults = { ...this.defaults, ...opts };
          });
          return this;
      }
      setOptions(opt) {
          this.defaults = { ...this.defaults, ...opt };
          return this;
      }
      lexer(src, options) {
          return _Lexer.lex(src, options ?? this.defaults);
      }
      parser(tokens, options) {
          return _Parser.parse(tokens, options ?? this.defaults);
      }
      parseMarkdown(blockType) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const parse = (src, options) => {
              const origOpt = { ...options };
              const opt = { ...this.defaults, ...origOpt };
              const throwError = this.onError(!!opt.silent, !!opt.async);
              // throw error if an extension set async to true but parse was called with async: false
              if (this.defaults.async === true && origOpt.async === false) {
                  return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
              }
              // throw error in case of non string input
              if (typeof src === 'undefined' || src === null) {
                  return throwError(new Error('marked(): input parameter is undefined or null'));
              }
              if (typeof src !== 'string') {
                  return throwError(new Error('marked(): input parameter is of type '
                      + Object.prototype.toString.call(src) + ', string expected'));
              }
              if (opt.hooks) {
                  opt.hooks.options = opt;
                  opt.hooks.block = blockType;
              }
              const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);
              const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);
              if (opt.async) {
                  return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                      .then(src => lexer(src, opt))
                      .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)
                      .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)
                      .then(tokens => parser(tokens, opt))
                      .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)
                      .catch(throwError);
              }
              try {
                  if (opt.hooks) {
                      src = opt.hooks.preprocess(src);
                  }
                  let tokens = lexer(src, opt);
                  if (opt.hooks) {
                      tokens = opt.hooks.processAllTokens(tokens);
                  }
                  if (opt.walkTokens) {
                      this.walkTokens(tokens, opt.walkTokens);
                  }
                  let html = parser(tokens, opt);
                  if (opt.hooks) {
                      html = opt.hooks.postprocess(html);
                  }
                  return html;
              }
              catch (e) {
                  return throwError(e);
              }
          };
          return parse;
      }
      onError(silent, async) {
          return (e) => {
              e.message += '\nPlease report this to https://github.com/markedjs/marked.';
              if (silent) {
                  const msg = '<p>An error occurred:</p><pre>'
                      + escape(e.message + '', true)
                      + '</pre>';
                  if (async) {
                      return Promise.resolve(msg);
                  }
                  return msg;
              }
              if (async) {
                  return Promise.reject(e);
              }
              throw e;
          };
      }
  }

  const markedInstance = new Marked();
  function marked(src, opt) {
      return markedInstance.parse(src, opt);
  }
  /**
   * Sets the default options.
   *
   * @param options Hash of options
   */
  marked.options =
      marked.setOptions = function (options) {
          markedInstance.setOptions(options);
          marked.defaults = markedInstance.defaults;
          changeDefaults(marked.defaults);
          return marked;
      };
  /**
   * Gets the original marked default options.
   */
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  /**
   * Use Extension
   */
  marked.use = function (...args) {
      markedInstance.use(...args);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
  };
  /**
   * Run callback for every token
   */
  marked.walkTokens = function (tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
  };
  /**
   * Compiles markdown to HTML without enclosing `p` tag.
   *
   * @param src String of markdown source to be compiled
   * @param options Hash of options
   * @return String of compiled HTML
   */
  marked.parseInline = markedInstance.parseInline;
  /**
   * Expose
   */
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  marked.options;
  marked.setOptions;
  marked.use;
  marked.walkTokens;
  marked.parseInline;
  _Parser.parse;
  _Lexer.lex;

  /*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE */

  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create
  } = Object; // eslint-disable-line import/no-mutable-exports
  let {
    apply,
    construct
  } = typeof Reflect !== 'undefined' && Reflect;
  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }
  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }
  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct(Func, args) {
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const arraySplice = unapply(Array.prototype.splice);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  /**
   * Creates a new function that calls the given function with a specified thisArg and arguments.
   *
   * @param func - The function to be wrapped and called.
   * @returns A new function that calls the given function with a specified thisArg and arguments.
   */
  function unapply(func) {
    return function (thisArg) {
      if (thisArg instanceof RegExp) {
        thisArg.lastIndex = 0;
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  /**
   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
   *
   * @param func - The constructor function to be wrapped and called.
   * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
   */
  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  /**
   * Add properties to a lookup table
   *
   * @param set - The set to which elements will be added.
   * @param array - The array containing elements to be added to the set.
   * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
   * @returns The modified set with added elements.
   */
  function addToSet(set, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }
    let l = array.length;
    while (l--) {
      let element = array[l];
      if (typeof element === 'string') {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set[element] = true;
    }
    return set;
  }
  /**
   * Clean up an array to harden against CSPP
   *
   * @param array - The array to be cleaned.
   * @returns The cleaned version of the array
   */
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array, index);
      if (!isPropertyExist) {
        array[index] = null;
      }
    }
    return array;
  }
  /**
   * Shallow clone an object
   *
   * @param object - The object to be cloned.
   * @returns A new object that copies the original.
   */
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === 'object' && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  /**
   * This method automatically checks if the prop is function or getter and behaves accordingly.
   *
   * @param object - The object to look up the getter function in its prototype chain.
   * @param prop - The property name for which to find the getter function.
   * @returns The getter function found in the prototype chain or a fallback function.
   */
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }

  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
  const text = freeze(['#text']);

  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  const DOCTYPE_NAME = seal(/^html$/i);
  const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

  var EXPRESSIONS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ARIA_ATTR: ARIA_ATTR,
    ATTR_WHITESPACE: ATTR_WHITESPACE,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT,
    DATA_ATTR: DATA_ATTR,
    DOCTYPE_NAME: DOCTYPE_NAME,
    ERB_EXPR: ERB_EXPR,
    IS_ALLOWED_URI: IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR: MUSTACHE_EXPR,
    TMPLIT_EXPR: TMPLIT_EXPR
  });

  /* eslint-disable @typescript-eslint/indent */
  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
  const NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12 // Deprecated
  };
  const getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param trustedTypes The policy factory.
   * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
   * @return The policy created (or null, if Trusted Types
   * are not supported or creating the policy failed).
   */
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }
    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    let suffix = null;
    const ATTR_NAME = 'data-tt-policy-suffix';
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html) {
          return html;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };
  const _createHooksMap = function _createHooksMap() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
    const DOMPurify = root => createDOMPurify(root);
    DOMPurify.version = '3.2.5';
    DOMPurify.removed = [];
    if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document
    } = window;
    const originalDocument = document;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node,
      Element,
      NodeFilter,
      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser,
      trustedTypes
    } = window;
    const ElementPrototype = Element.prototype;
    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    const remove = lookupGetter(ElementPrototype, 'remove');
    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      const template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = '';
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
    const {
      MUSTACHE_EXPR,
      ERB_EXPR,
      TMPLIT_EXPR,
      DATA_ATTR,
      ARIA_ATTR,
      IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE,
      CUSTOM_ELEMENT
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */
    /* allowed element names */
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    /* Allowed attribute names */
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    /*
     * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    let FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    let FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */
    let ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */
    let ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
     * Usually removed due to a mXSS issue in jQuery 3.0 */
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    let SAFE_FOR_TEMPLATES = false;
    /* Output should be safe even for XML used within HTML and alike.
     * This means, DOMPurify removes comments when containing risky content.
     */
    let SAFE_FOR_XML = true;
    /* Decide if document with <html>... should be returned */
    let WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */
    let SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    let FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    let RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    let RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    let RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */
    let SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (§7.3.3)
     *   - DOM Tree Accessors (§3.1.5)
     *   - Form Element Parent-Child Relations (§4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
     *   - HTMLCollection (§4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */
    let KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    let IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */
    let USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    /* Tags that are safe for data: URIs */
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    /* Attributes safe for values like "javascript:" */
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
    // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    /* Parsing of strict XHTML documents */
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    let transformCaseFunc = null;
    /* Keep a reference to config to pass to hooks */
    let CONFIG = null;
    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */
    const formElement = document.createElement('form');
    const isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param cfg optional config literal
     */
    // eslint-disable-next-line complexity
    const _parseConfig = function _parseConfig() {
      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */
      if (!cfg || typeof cfg !== 'object') {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE =
      // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
      /* Set configuration parameters */
      ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        // Overwrite existing TrustedTypes policy.
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        // Sign local variables required by `sanitize`.
        emptyHTML = trustedTypesPolicy.createHTML('');
      } else {
        // Uninitialized policy, attempt to initialize the internal dompurify policy.
        if (trustedTypesPolicy === undefined) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        // If creating the internal policy succeeded sign internal variables.
        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
          emptyHTML = trustedTypesPolicy.createHTML('');
        }
      }
      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    /**
     * @param element a DOM element whose namespace is being checked
     * @returns Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    const _checkValidNamespace = function _checkValidNamespace(element) {
      let parent = getParentNode(element);
      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: 'template'
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }
        // The only way to switch from MathML to SVG is via`
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }
        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }
        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      // For XHTML and XML documents that support custom namespaces
      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
      // Return false just in case.
      return false;
    };
    /**
     * _forceRemove
     *
     * @param node a DOM node
     */
    const _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        getParentNode(node).removeChild(node);
      } catch (_) {
        remove(node);
      }
    };
    /**
     * _removeAttribute
     *
     * @param name an Attribute name
     * @param element a DOM node
     */
    const _removeAttribute = function _removeAttribute(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      // We void attribute values for unremovable "is" attributes
      if (name === 'is') {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_) {}
        } else {
          try {
            element.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param dirty - a string of dirty markup
     * @return a DOM, filled with the dirty markup
     */
    const _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
     *
     * @param root The root element or node to start traversing on.
     * @return The created NodeIterator
     */
    const _createNodeIterator = function _createNodeIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
    };
    /**
     * _isClobbered
     *
     * @param element element to check for clobbering attacks
     * @return true if clobbered, false if safe
     */
    const _isClobbered = function _isClobbered(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
    };
    /**
     * Checks whether the given object is a DOM node.
     *
     * @param value object to check whether it's a DOM node
     * @return true is object is a DOM node
     */
    const _isNode = function _isNode(value) {
      return typeof Node === 'function' && value instanceof Node;
    };
    function _executeHooks(hooks, currentNode, data) {
      arrayForEach(hooks, hook => {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    }
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     * @param currentNode to check for permission to exist
     * @return true if node was killed, false if left alive
     */
    const _sanitizeElements = function _sanitizeElements(currentNode) {
      let content = null;
      /* Execute a hook if present */
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      /* Now let's check the element's type and name */
      const tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      /* Detect mXSS attempts abusing namespace confusion */
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      /* Remove any occurrence of processing instructions */
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      /* Remove any kind of possibly harmful comments */
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              const childClone = cloneNode(childNodes[i], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      /* Make sure that older browsers don't get fallback-tag mXSS */
      if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        /* Get the element's text content */
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          content = stringReplace(content, expr, ' ');
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param lcTag Lowercase tag name of containing element.
     * @param lcName Lowercase attribute name.
     * @param value Attribute value.
     * @return Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
        // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
        return false;
      } else ;
      return true;
    };
    /**
     * _isBasicCustomElement
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     *
     * @param tagName name of the tag of the node to sanitize
     * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
     */
    const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
      return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param currentNode to sanitize
     */
    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      /* Execute a hook if present */
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      /* Check if we have attributes; if not we might have a text node */
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: undefined
      };
      let l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        const attr = attributes[l];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        let value = name === 'value' ? attrValue : stringTrim(attrValue);
        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */
        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode);
          // Prefix the value and later re-create the attribute with the sanitized value
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Work around a security issue with comments inside attributes */
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */
        _removeAttribute(name, currentNode);
        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            value = stringReplace(value, expr, ' ');
          });
        }
        /* Is `value` valid for this attribute? */
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        /* Handle attributes that require Trusted Types */
        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
          if (namespaceURI) ; else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case 'TrustedHTML':
                {
                  value = trustedTypesPolicy.createHTML(value);
                  break;
                }
              case 'TrustedScriptURL':
                {
                  value = trustedTypesPolicy.createScriptURL(value);
                  break;
                }
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_) {}
      }
      /* Execute a hook if present */
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param fragment to iterate over recursively
     */
    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      /* Execute a hook if present */
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        /* Sanitize tags and elements */
        _sanitizeElements(shadowNode);
        /* Check attributes next */
        _sanitizeAttributes(shadowNode);
        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
      }
      /* Execute a hook if present */
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }
      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        if (typeof dirty.toString === 'function') {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        } else {
          throw typeErrorCreate('toString is not a function');
        }
      }
      /* Return dirty HTML if DOMPurify cannot run */
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */
      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        /* Initialize the document to work on */
        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Sanitize tags and elements */
        _sanitizeElements(currentNode);
        /* Check attributes next */
        _sanitizeAttributes(currentNode);
        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */
      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }
      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          serializedHTML = stringReplace(serializedHTML, expr, ' ');
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function () {
      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function (entryPoint, hookFunction) {
      if (hookFunction !== undefined) {
        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function (entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function () {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();

  // src/utils/renderMarkdown.js

  function renderMarkdown(mdText) {
    // تعطيل تشويش العناوين وتعطيل IDs التلقائية
    const rawHtml = marked(mdText, {
      mangle: false,
      headerIds: false
    });
    // تنقية الـ HTML من أي سكريبتات أو هجمات XSS
    return purify.sanitize(rawHtml);
  }

  /**
   * مكوّن عرض رسائل الدردشة
   */
  class ChatMessage extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this._content = '';
    }

    connectedCallback() {
      const sender = this.getAttribute('sender') || 'bot';
      const avatar = this.getAttribute('avatar') || 'https://alaghbry0.github.io/chat-widget/profile.png';
      const messageId = this.getAttribute('message-id') || '';

      // قراءة محتوى Markdown الخام
      this._content = this.getAttribute('data-md') || this.textContent || '';

      // إعداد CSS جديد يتضمن تنسيقات للقوائم والروابط
      const style = document.createElement('style');
      style.textContent = `
      :host { display: block; width: 115%; margin-bottom: 16px; }

      .message {
        display: flex;
        flex-direction: column;
        max-width: 80%;
        animation: fadeIn 0.3s ease-in-out, slideIn 0.2s ease-out;
      }

      .message-user {
        align-self: flex-end;
        align-items: flex-end;
      }

      .message-bot {
        align-self: flex-start;
        align-items: flex-start;
      }

      .message-header {
        display: flex;
        align-items: center;
        margin-bottom: 4px;
      }

      .avatar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        margin-right: 8px;
        background-color: var(--primary-color);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
      }

      .message-content {
        padding: 5px 10px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.6;
        position: relative;
        overflow-wrap: break-word;
        word-break: break-word;
      }

      .message-user .message-content {
        background: linear-gradient(135deg, #007BFF, #0056b3);
        color: #fff;
        border-bottom-right-radius: 4px;
      }

      .message-bot .message-content {
        background: linear-gradient(135deg, #F8F9FA, #FFFFFF);
        color: #333;
        border-bottom-left-radius: 4px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      }

      .message-time {
        font-size: 11px;
        color: var(--text-secondary);
        margin-top: 4px;
        opacity: 0.8;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slideIn {
        from { transform: translateY(10px); }
        to { transform: translateY(0); }
      }

      /* تنسيقات العناصر في الرسالة */
      .message-content h1, .message-content h2, .message-content h3 {
        margin: 12px 0 8px 0;
        font-weight: 600;
      }

      .message-content h1 { font-size: 16px; }
      .message-content h2 { font-size: 14px; }
      .message-content h3 { font-size: 13px; }

      /* تنسيقات القوائم */
      .message-content ul, .message-content ol {
        padding-left: 20px;
        margin: 8px 0;
      }

      .message-content li {
        margin-bottom: 4px;
      }

      .message-content li.nested {
        margin-left: 16px;
      }

      /* تنسيقات الروابط - معدّلة لتشبه الأزرار */
      .message-content a {
        color: inherit;
        text-decoration: none;
        display: inline-block;
        padding: 6px 12px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 16px;
        transition: background 0.2s ease;
      }

      .message-user .message-content a {
        color: #fff;
        background: rgba(255, 255, 255, 0.2);
      }

      .message-bot .message-content a {
        color: #007BFF;
        background: rgba(0, 123, 255, 0.1);
      }

      .message-content a::after {
        content: " ↗";
        font-size: 0.8em;
        opacity: 0.8;
      }

      /* تنسيقات الكود */
      .message-content code {
        background: rgba(0,0,0,0.1);
        border-radius: 3px;
        padding: 2px 4px;
        font-family: monospace;
      }

      .message-user .message-content code {
        background: rgba(255,255,255,0.2);
      }

      /* أزرار التفاعل */
      .message-actions {
        display: none;
        position: absolute;
        top: -16px;
        right: 0;
        background: #fff;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .message:hover .message-actions {
        display: flex;
      }

      .action-button {
        padding: 4px 8px;
        background: #fff;
        color: #666;
        border: none;
        cursor: pointer;
        font-size: 12px;
        border-radius: 4px;
      }

      .action-button:hover {
        background: #f1f1f1;
      }
    `;

      // إنشاء عنصر الرسالة
      const messageEl = document.createElement('div');
      messageEl.className = `message message-${sender}`;
      messageEl.setAttribute('data-message-id', messageId);

      // تحويل Markdown إلى HTML آمن
      const html = renderMarkdown(this._content);

      messageEl.innerHTML = `
      <div class="message-header">
        ${sender === 'bot'
          ? (avatar
              ? `<img class="avatar" src="${avatar}" alt="Bot Avatar">`
              : `<div class="avatar">B</div>`)
          : ''}
      </div>
      <div class="message-content">${html}</div>
      <div class="message-time">${this._formatTime(new Date())}</div>
      ${sender === 'bot' ? `
        <div class="message-actions">
          <button class="action-button copy-btn">نسخ</button>
        </div>
      ` : ''}
    `;

      this.shadowRoot.append(style, messageEl);
      this._activateControls();
      this._setupLinkTargets();
    }

    // دالة لتحديث محتوى الرسالة (للاستجابة المتدفقة)
    updateContent(newContent) {
      if (newContent === this._content) return;
      this._content = newContent;

      const contentEl = this.shadowRoot.querySelector('.message-content');
      if (contentEl) {
        contentEl.innerHTML = renderMarkdown(newContent);
        this._activateControls();
        this._setupLinkTargets();
      }
    }

    _activateControls() {
      // تفعيل زر النسخ
      const copyBtn = this.shadowRoot.querySelector('.copy-btn');
      if (copyBtn) {
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(this._content)
          .then(() => {
            copyBtn.textContent = 'تم النسخ';
            setTimeout(() => {
              copyBtn.textContent = 'نسخ';
            }, 2000);
          })
          .catch(err => {
            console.error('فشل النسخ:', err);
          });
        });
      }
    }

    // دالة جديدة لتعيين target="_blank" للروابط
    _setupLinkTargets() {
      const links = this.shadowRoot.querySelectorAll('.message-content a');
      links.forEach(link => {
        link.setAttribute('target', '_blank');
        link.setAttribute('rel', 'noopener noreferrer');
      });
    }

    _formatTime(date) {
      const hh = date.getHours().toString().padStart(2, '0');
      const mm = date.getMinutes().toString().padStart(2, '0');
      return `${hh}:${mm}`;
    }
  }

  customElements.define('chat-message', ChatMessage);

  // src/components/suggestions.js

  /**
   * مكون اقتراحات الرسائل السريعة
   */
  class ChatSuggestions extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this._suggestions = [];
    }

    connectedCallback() {
      this._render();
    }

    set suggestions(value) {
      if (Array.isArray(value)) {
        this._suggestions = value;
        if (this.shadowRoot) {
          this._render();
        }
      }
    }

    get suggestions() {
      return this._suggestions;
    }

    _render() {
      const style = document.createElement('style');
      style.textContent = `
      :host {
        display: block;
        margin: 16px 0;
      }

      .suggestions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 16px;
      }

      .suggestion {
        background: linear-gradient(to right, #F8F9FA, #FFFFFF);
        color: var(--text-color, #333);
        border: 1px solid var(--border-color, #E6E6E6);
        border-radius: 16px;
        padding: 8px 16px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 200px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      }

      .suggestion:hover {
        background: linear-gradient(to right, var(--primary-color, #007BFF), var(--primary-hover, #0056b3));
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      }

      .title {
        font-size: 14px;
        color: var(--text-secondary, #666);
        margin-bottom: 8px;
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .suggestion {
        animation: fadeIn 0.3s ease-in-out;
        animation-fill-mode: both;
      }

      .suggestion:nth-child(1) { animation-delay: 0.1s; }
      .suggestion:nth-child(2) { animation-delay: 0.2s; }
      .suggestion:nth-child(3) { animation-delay: 0.3s; }
      .suggestion:nth-child(4) { animation-delay: 0.4s; }

      @media (max-width: 576px) {
        .suggestions {
          gap: 6px;
        }

        .suggestion {
          padding: 6px 12px;
          font-size: 12px;
        }
      }
    `;

      const container = document.createElement('div');
      container.innerHTML = `
      <div class="title">يمكنك أن تسأل:</div>
      <div class="suggestions">
        ${this._suggestions.map(suggestion => `
          <button class="suggestion" aria-label="${suggestion}">${suggestion}</button>
        `).join('')}
      </div>
    `;

      this.shadowRoot.innerHTML = '';
      this.shadowRoot.appendChild(style);
      this.shadowRoot.appendChild(container);

      const suggestionButtons = this.shadowRoot.querySelectorAll('.suggestion');
      suggestionButtons.forEach(button => {
        button.addEventListener('click', () => {
          const suggestion = button.textContent;
          this.dispatchEvent(new CustomEvent('suggestion-clicked', {
            detail: { suggestion },
            bubbles: true,
            composed: true
          }));
        });
      });
    }
  }

  customElements.define('chat-suggestions', ChatSuggestions);

  /**
   * مكون مؤشر الكتابة
   */
  class TypingIndicator extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
    }

    connectedCallback() {
      const avatar = this.getAttribute('avatar') || '';
      const direction = document.dir || this.getAttribute('direction') || 'rtl';

      // إعداد CSS
      const style = document.createElement('style');
      style.textContent = `
      :host {
        display: block;
        width: 100%;
        animation: fadeIn 0.3s ease-in-out;
      }

      .typing-indicator {
        display: flex;
        align-items: flex-end;
        margin-bottom: 10px;
        max-width: 85%;
        align-self: flex-start;
      }

      .avatar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        margin-right: ${direction === 'rtl' ? '0' : '8px'};
        margin-left: ${direction === 'rtl' ? '8px' : '0'};
        background-color: var(--primary-color, #007BFF);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        flex-shrink: 0;
      }

      .typing-bubble {
        background: transparent;
        padding: 8px 12px;
        display: flex;
        align-items: center;
      }

      .dots-container {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 20px;
      }

      .dot {
        width: 6px;
        height: 6px;
        background-color: var(--text-secondary, #666);
        border-radius: 50%;
        margin: 0 2px;
        opacity: 0.7;
        transition: transform 0.2s ease-in-out;
        animation: bounce 1.2s infinite;
      }

      .dot:nth-child(1) {
        animation-delay: 0s;
      }

      .dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes bounce {
        0%, 60%, 100% {
          transform: translateY(0);
        }
        30% {
          transform: translateY(-4px);
        }
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
    `;

      // إضافة التحسينات: استخدام avatar component إذا كان موجودًا
      const avatarHTML = avatar ?
        `<img class="avatar" src="${avatar}" alt="Bot" />` :
        `<div class="avatar">${this.getAttribute('avatar-text') || 'B'}</div>`;

      const template = document.createElement('div');
      template.className = 'typing-indicator';
      template.innerHTML = `
      ${avatarHTML}
      <div class="typing-bubble">
        <div class="dots-container">
          <div class="dot"></div>
          <div class="dot"></div>
          <div class="dot"></div>
        </div>
      </div>
    `;

      // إضافة الأنماط والقالب للظل
      this.shadowRoot.appendChild(style);
      this.shadowRoot.appendChild(template);
    }

    // دالة لتحديث صورة الأفاتار
    updateAvatar(avatarSrc) {
      const avatarEl = this.shadowRoot.querySelector('.avatar');
      if (avatarEl && avatarSrc) {
        if (avatarEl.tagName === 'IMG') {
          avatarEl.src = avatarSrc;
        } else {
          // استبدال العنصر تمامًا
          const parent = avatarEl.parentNode;
          const img = document.createElement('img');
          img.className = 'avatar';
          img.src = avatarSrc;
          img.alt = 'Bot';
          parent.replaceChild(img, avatarEl);
        }
      }
    }
  }

  // تسجيل المكون
  customElements.define('typing-indicator', TypingIndicator);

  // src/components/avatar.js

  /**
   * مكون الصورة الرمزية
   */
  class ChatAvatar extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
    }

    connectedCallback() {
      this._render();
    }

    _render() {
      const src = this.getAttribute('src') || '';
      const fallback = this.getAttribute('fallback') || 'B';
      const bgColor = this.getAttribute('bg-color') || '#007BFF';
      const size = this.getAttribute('size') || '32px';

      const style = document.createElement('style');
      style.textContent = `
      :host {
        display: inline-block;
      }

      .avatar {
        width: ${size};
        height: ${size};
        border-radius: 50%;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        color: white;
        background: linear-gradient(135deg, ${bgColor}, ${this._darkenColor(bgColor, 20)});
        font-size: calc(${size} * 0.4);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: transform 0.2s ease-out;
      }

      .avatar:hover {
        transform: scale(1.05);
      }

      .avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: opacity 0.2s;
      }

      @keyframes avatarFadeIn {
        from { opacity: 0; transform: scale(0.8); }
        to { opacity: 1; transform: scale(1); }
      }

      .avatar {
        animation: avatarFadeIn 0.3s ease-out forwards;
      }
    `;

      const template = document.createElement('template');

      if (src) {
        template.innerHTML = `
        <div class="avatar">
          <img src="${src}" alt="Avatar" onerror="this.style.display='none'; this.parentNode.textContent='${fallback}'" />
        </div>
      `;
      } else {
        template.innerHTML = `
        <div class="avatar">${fallback}</div>
      `;
      }

      this.shadowRoot.innerHTML = '';
      this.shadowRoot.appendChild(style);
      this.shadowRoot.appendChild(template.content.cloneNode(true));
    }

    _darkenColor(color, percent) {
      // Simple function to darken a hex color
      const num = parseInt(color.replace('#', ''), 16),
        amt = Math.round(2.55 * percent),
        R = (num >> 16) - amt,
        G = (num >> 8 & 0x00FF) - amt,
        B = (num & 0x0000FF) - amt;
      return '#' + (0x1000000 + (R < 0 ? 0 : R) * 0x10000 + (G < 0 ? 0 : G) * 0x100 + (B < 0 ? 0 : B)).toString(16).slice(1);
    }

    static get observedAttributes() {
      return ['src', 'fallback', 'bg-color', 'size'];
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue !== newValue) {
        this._render();
      }
    }
  }

  customElements.define('chat-avatar', ChatAvatar);

  // src/services/chat-service.js

  /**
   * خدمة الاتصال بالخادم للدردشة باستخدام SSE
   */
  class ChatService {
    /**
     * إرسال رسالة إلى الخادم والحصول على دفق SSE للردود
     * @param {string} url - عنوان URL للخادم
     * @param {Object} data - بيانات الرسالة للإرسال
     * @returns {EventSource} - موجّه أحداث SSE
     */
    async sendMessage(url, data) {
      try {
        console.log("Sending message to:", url, data);

        // استخدام fetch مع POST بدلاً من EventSource
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // إنشاء قارئ دفق لمعالجة استجابة SSE
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        // إنشاء كائن مماثل لـ EventSource للتوافق مع بقية الكود
        const eventSourceMock = {
          listeners: {
            message: [],
            chunk: [],
            end: [],
            tool_call: [],
            tool_result: [],
            error: [],
            open: []
          },

          onmessage: null,
          onchunk: null,
          onend: null,
          ontool_call: null,
          ontool_result: null,
          onerror: null,
          onopen: null,
          onclose: null,

          addEventListener(event, callback) {
            if (!this.listeners[event]) {
              this.listeners[event] = [];
            }
            this.listeners[event].push(callback);
          },

          removeEventListener(event, callback) {
            const arr = this.listeners[event] || [];
            const idx = arr.indexOf(callback);
            if (idx !== -1) arr.splice(idx, 1);
          },

          close() {
            reader.cancel().then(() => {
              // تنفيذ حدث الإغلاق
              if (this.onclose) {
                this.onclose({ type: 'close' });
              }
              (this.listeners.close || []).forEach(cb =>
                cb({ type: 'close' })
              );
            });
          }
        };

        // قراءة الدفق وإطلاق الأحداث
        this._processStream(reader, decoder, eventSourceMock);

        // تشغيل حدث open
        setTimeout(() => {
          if (eventSourceMock.onopen) {
            eventSourceMock.onopen({ type: 'open' });
          }
          (eventSourceMock.listeners.open || []).forEach(cb =>
            cb({ type: 'open' })
          );
        }, 0);

        return eventSourceMock;
      } catch (error) {
        console.error('Error in sendMessage:', error);
        throw error;
      }
    }

    /**
     * معالجة دفق SSE
     * @param {ReadableStreamDefaultReader} reader
     * @param {TextDecoder} decoder
     * @param {Object} eventSource
     */
    _processStream(reader, decoder, eventSource) {
      let buffer = '';
      let pendingRead = null;

      const emitEvent = (type, dataStr, eventId) => {
        try {
          // محاولة تحليل JSON إذا كان البيانات بتنسيق JSON
          const jsonData = JSON.parse(dataStr);
          const ev = {
            data: dataStr,
            type,
            lastEventId: eventId,
            json: jsonData // إضافة البيانات المحللة كـ JSON
          };

          // أولاً handler النوعي أو العام
          const handler = eventSource['on' + type] || eventSource.onmessage;
          if (handler) handler(ev);

          // ثم كل المستمعين المسجلين
          (eventSource.listeners[type] || []).forEach(cb => cb(ev));
        } catch (e) {
          // إذا فشل التحليل، نرسل البيانات كما هي نصياً
          const ev = { data: dataStr, type, lastEventId: eventId };

          // نفس الشيء: handler النوعي أو العام
          const handler = eventSource['on' + type] || eventSource.onmessage;
          if (handler) handler(ev);

          // ثم المستمعين
          (eventSource.listeners[type] || []).forEach(cb => cb(ev));
        }
      };

      const processChunk = (chunk) => {
        // تعديل ليعمل مع مختلف أنواع الفواصل السطرية
        buffer += chunk;

        // تقسيم على الفاصل الفارغ بين الأحداث (سطر فارغ)
        const eventBlocks = buffer.split(/\r?\n\r?\n/);

        // آخر كتلة قد تكون غير مكتملة - نحتفظ بها للقراءة التالية
        buffer = eventBlocks.pop() || '';

        eventBlocks.forEach(eventBlock => {
          if (!eventBlock.trim()) return; // تجاوز الكتل الفارغة

          const lines = eventBlock.split(/\r?\n/);
          let eventType = 'message'; // النوع الافتراضي
          let data = '';
          let eventId = '';

          lines.forEach(line => {
            if (line.startsWith('event:')) {
              eventType = line.substring(6).trim();
            } else if (line.startsWith('data:')) {
              data += (data ? '\n' : '') + line.substring(5).trim();
            } else if (line.startsWith('id:')) {
              eventId = line.substring(3).trim();
            } else if (line.startsWith(':')) ;
          });

          if (data) {
            emitEvent(eventType, data, eventId);
          }
        });
      };

      // دالة تكرارية لقراءة الدفق
      const readNext = () => {
        pendingRead = reader.read().then(({ value, done }) => {
          if (done) {
            // عند انتهاء الدفق، نرسل حدث "end" للتنبيه
            emitEvent('end', '', '');
            return;
          }

          // فك ترميز المحتوى
          const chunk = decoder.decode(value, { stream: true });
          processChunk(chunk);

          // استمر بالقراءة
          return readNext();
        }).catch(err => {
          console.error('Error reading stream:', err);
          emitEvent('error', JSON.stringify({
            message: err.message || 'Error reading stream'
          }), '');
        });

        return pendingRead;
      };

      // ابدأ القراءة
      readNext();
    }
  }

  // استيراد الأنماط
  const styles = `
  :host {
    --primary-color: #007BFF;
    --primary-hover: #0069d9;
    --bg-color: #fff;
    --header-bg: #467df2;
    --text-color: #333;
    --text-secondary: #666;
    --message-bg-user: linear-gradient(180deg, #007BFF, #0056B3);
    --message-color-user: #fff;
    --message-bg-bot: linear-gradient(180deg, #F8F9FA, #FFFFFF);
    --message-color-bot: #666;
    --border-color: #f7eded;
    --footer-bg: rgba(249, 250, 251, 0.8);
    --bubble-size: 56px;
    --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    --header-dark: #1F2937;

    font-family: Roboto, Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
    position: fixed;
    z-index: 9999;
    box-sizing: border-box;
  }

  :host([theme="dark"]) {
    --primary-color: #375FFF;
    --primary-hover: #2D4ECC;
    --bg-color: #F0F0F0;
    --header-bg: #2D2D2D;
    --header-dark: #0F172A;
    --text-color: #fff;
    --text-secondary: #B0B0B0;
    --message-bg-user: linear-gradient(180deg, #375FFF, #2D4ECC);
    --message-color-user: #fff;
    --message-bg-bot: linear-gradient(180deg, #2D2D2D, #1E1E1E);
    --message-color-bot: #E0E0E0;
    --border-color: #3D3D3D;
    --footer-bg: rgba(30, 30, 30, 0.85);
  }

  :host([position="bottom-right"]) .chat-container {
    bottom: calc(var(--bubble-size) + 17px);
    right: 24px;
    left: auto;
  }

  :host([position="bottom-left"]) .chat-container {
    bottom: calc(var(--bubble-size) + 16px);
    left: 24px;
    right: auto;
  }

  :host([direction="rtl"]) {
    direction: rtl;
    text-align: right;
  }

  .chat-container {
    z-index: 9999;
    position: fixed;
    display: flex;
    flex-direction: column;
    width: 400px;
    max-width: 90vw;
    height: 85vh;
    background-color: var(--bg-color);
    border-radius: 15px;
    overflow: hidden;
    box-shadow: var(--shadow);
    transition: transform 0.3s ease, opacity 0.3s ease;
    transform: translateY(16px);
    opacity: 0;
    pointer-events: none;
  }

  .chat-container.open {
    transform: translateY(0);
    opacity: 1;
    pointer-events: all;
  }

  .chat-header {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10;
  transition: height 0.3s ease;
  transform: translateZ(0); /* تحسين الأداء */
}



/* حساب ارتفاع messages-container مع أخذ الهيدر في الاعتبار */
.messages-container {
  padding-top: 12px;
  height: 100%;
}

  .top-bar {
    height: 55px;
    background-color: var(--header-dark);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 16px;
  }

  .top-bar-title {
    color: white;
    font-size: 14px;
    font-weight: 600;
    margin: 0;
  }

  .top-bar-actions {
    display: flex;
    gap: 8px;
  }

  .top-bar-button {
    width: 24px;
    height: 24px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    cursor: pointer;
    color: white;
    opacity: 0.8;
  }

  .top-bar-button:hover {
    opacity: 1;
  }

  .profile-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: white;
    padding: 16px 0;
    transition: transform 0.3s ease, opacity 0.3s ease, max-height 0.3s ease;
    max-height: 150px;
    overflow: hidden;
  }

  .profile-header.hidden {
    max-height: 0;
    padding: 0;
    opacity: 0;
    transform: translateY(-100%);
  }

  .profile-avatar {
    width: 64px;
    height: 64px;
  }

  .header-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--text-color);
    margin: 8px 0 0 0;
  }

  .header-subtitle {
    font-size: 14px;
    color: var(--text-secondary);
    margin: 8px 0 0 0;
  }

  .messages-container {
    flex: 1;
    padding: 12px 16px;
    overflow-y: auto;
    overflow-x: hidden;
    background-color: var(--bg-color);
    display: flex;
    flex-direction: column;
    gap: 12px;
    scroll-behavior: smooth;
    border-top-left-radius: 16px;
    border-top-right-radius: 12px;
  }

  .messages-container::-webkit-scrollbar {
    width: 6px;
  }

  .messages-container::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }

  .messages-container::-webkit-scrollbar-track {
    background-color: transparent;
  }

  .chat-footer {
  padding: 12px 16px; /* تقليل padding العلوي والسفلي قليلاً */
  background-color: var(--footer-bg);
  border-top: 1px solid var(--border-color);
  }
    .input-area {
  margin-bottom: 8px; /* إضافة مسافة بين حقل الإدخال والنص السفلي */
}


  .chat-input-wrapper {
  flex: 1;
  display: flex; /* <<< تعديل: استخدام flex لتوزيع العناصر الداخلية */
  align-items: center; /* <<< تعديل: محاذاة العناصر عموديًا في المنتصف */
  position: relative;
  background-color: var(--bg-color); /* أو #F0F0F0 لخلفية رمادية فاتحة */
  border: 2px solid var(--border-color);
  border-radius: 15px;
  padding: 4px 8px 4px 16px; /* <<< تعديل: ضبط الحشو الداخلي */
  gap: 8px; /* مسافة بين العناصر الداخلية */
}


.chat-input {
    width: 100%;
    min-height: 11px;
    max-height: 150px;
    word-spacing: -0.17em !important;
    white-space: pre-wrap;
    letter-spacing: -0.02em;
    border: none;
    outline: none;
    background: transparent;
    color: var(--text-color);
    font-size: 14px;
    line-height: 1.4;
    resize: none;
    overflow-y: hidden;
  }

  .chat-input::placeholder {
    color: var(--text-secondary);
  }

  .chat-input::-webkit-scrollbar {
    width: 4px;
  }

  .chat-input::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 2px;
  }


/* --- نمط جديد لزر الميكروفون --- */
.mic-button {
  width: 32px; /* حجم مناسب */
  height: 32px;
  border-radius: 50%;
  background: none; /* بدون خلفية */
  color: var(--text-secondary); /* لون الأيقونة */
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: color 0.2s;
  flex-shrink: 0;
  padding: 0;
}

.mic-button:hover {
  color: var(--text-color); /* تغيير اللون عند المرور */
}

.mic-button svg {
    width: 18px; /* حجم الأيقونة */
    height: 18px;
}


.send-button {
  width: 36px; /* <<< تعديل: حجم الزر الدائري */
  height: 36px;
  border-radius: 50%;
  /* <<< تعديل: تغيير لون الخلفية ليتناسب مع التصميم الجديد */
  background-color: #E0E0E0; /* لون رمادي فاتح كالمثال */
  /* أو يمكن استخدام متغير CSS إذا كان لديك واحد مناسب */
  /* background-color: var(--border-color); */
  color: var(--text-secondary); /* <<< تعديل: لون الأيقونة الافتراضي */
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s, transform 0.2s;
  flex-shrink: 0;
}

.send-button:not(:disabled) { /* نمط زر الإرسال عندما يكون فعالاً */
    background-color: var(--primary-color); /* <<< تعديل: العودة للون الأساسي عند التفعيل */
    color: white; /* <<< تعديل: لون الأيقونة عند التفعيل */
}

.send-button:not(:disabled):hover {
  background-color: var(--primary-hover); /* <<< تعديل: لون عند المرور وهو فعال */
}

.send-button:disabled {
  background-color: #E9ECEF; /* لون رمادي فاتح جداً عند التعطيل */
  color: #ADB5BD; /* لون أيقونة باهت */
  opacity: 1; /* لا نحتاج لـ opacity هنا لأننا نغير الألوان */
  cursor: not-allowed;
}

.send-button svg {
  width: 18px;
  height: 18px;
}

/* تمت إعادة تسمية الكلاس وتعديل النمط */
.footer-powered-by {
  text-align: center; /* <<< تعديل: توسيط النص */
  margin-top: 8px; /* مسافة أعلى النص */
  width: 100%; /* يأخذ العرض كامل للتوسيط */
}

/* تعديل نمط النص إذا لزم الأمر */
.powered-by {
  font-size: 12px;
  color: var(--text-secondary);
}

  .typing-bubble {
    background: transparent;
    padding: 0;
  }

  .dot {
    width: 8px;
    height: 8px;
    background: var(--text-secondary);
    border-radius: 50%;
    animation: bounce 1.2s infinite;
  }

  @keyframes bounce {
    0%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-6px); }
  }

  /* Mobile responsive styles */
  @media (max-width: 576px) {
    .chat-container {
      width: 100vw !important;
      max-width: 100vw !important;
      height: 100vh !important;
      right: 0 !important;
      left: 0 !important;
      bottom: 0 !important;
      border-radius: 0;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .chat-header, .chat-footer {
      border-radius: 0;
    }

    :host([position="bottom-right"]) .chat-container,
    :host([position="bottom-left"]) .chat-container {
      bottom: 0;
      right: 0;
    }

    .header-title {
      font-size: 16px;
    }

    .header-subtitle {
      font-size: 12px;
    }
  }
`;

  class ChatWidget extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this.isOpen = false;
      this.messages = [];
      this.isTyping = false;
      this.sessionId = this._generateSessionId();
      this.headerCollapsed = false;
      this.lastScrollPosition = 0;

      // استدعاء التهيئة
      this._initialize();
    }

    static get observedAttributes() {
      return [
        'project-id', 'theme', 'position', 'welcome-message',
        'api-url', 'direction', 'avatar', 'title', 'subtitle', 'powered-by'
      ];
    }

      _resetChat() {
     console.log('🔄 Resetting chat to initial state...');

     // 1. مسح مصفوفة الرسائل
     this.messages = [];

     // 2. إنشاء معرف جلسة جديد
     this.sessionId = this._generateSessionId(true);

     // 3. إعادة بناء الواجهة بالكامل
     this._render(); // يعيد بناء العناصر الداخلية

     // 4. استعادة حالة الرؤية
     if (this.isOpen) {
       if (this.chatContainer) {
         this.chatContainer.classList.add('open');
         console.log('Restored .open class after reset.');
       } else {
         console.error("Chat container not found immediately after render in _resetChat.");
       }
     }

     // --- 5. إعادة ربط المستمعات الداخلية بالعناصر الجديدة ---
     this._setupInternalListeners();

     // 6. إعادة إضافة رسالة الترحيب النصية والاقتراحات
     this._setupInitialChatState();

     console.log("Chat reset complete.");
   }
    // تعديل دالة _render في class ChatWidget

    _initialize() {
     // إنشاء خدمة الدردشة
     this.chatService = new ChatService();
     this.suggestionsElement = null;

     // التهيئة الأساسية للمكون
     this._render(); // 1. بناء الواجهة الأولية
     this._setupComponentListeners(); // 2. ربط المستمعات الخارجية (مرة واحدة)
     this._setupInternalListeners(); // 3. ربط المستمعات الداخلية (لأول مرة)
     this._setupInitialChatState(); // 4. إضافة رسالة الترحيب والاقتراحات

     console.log("Chat widget initialized.");
   }


  _render() {
    const styleEl = document.createElement('style');
    styleEl.textContent = styles; // الأنماط المعدلة أدناه

    const template = document.createElement('template');
    template.innerHTML = `
    <div class="chat-container">
      <div class="chat-header">
         <div class="top-bar">
           <chat-avatar
             size="24px"
             src="${this.getAttribute('avatar') || 'https://alaghbry0.github.io/chat-widget/profile.png'}"
             fallback="${(this.getAttribute('title') || 'Bot').charAt(0)}"
             bg-color="var(--primary-color)">
           </chat-avatar>
           <h4 class="top-bar-title">${this.getAttribute('title') || 'Exaado Assistant'}</h4>
           <div class="top-bar-actions">
             <button class="top-bar-button refresh-btn">
               <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                 <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
               </svg>
             </button>
             <button class="top-bar-button close-btn">
               <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                 <path d="M18 6 6 18M6 6l12 12"/>
               </svg>
             </button>
           </div>
         </div>
         </div>

       <div class="messages-container" id="messages" aria-live="polite">
         <div class="welcome-message">
           <chat-avatar
             class="welcome-avatar"
             size="75px"
             src="${this.getAttribute('avatar') || 'https://alaghbry0.github.io/chat-widget/profile.png'}"
             fallback="${(this.getAttribute('title') || 'Bot').charAt(0)}"
             bg-color="var(--primary-color)">
           </chat-avatar>
           <h3 class="welcome-title">${this.getAttribute('title') || 'Exaado Assistant'}</h3>
           <p class="welcome-subtitle">${this.getAttribute('subtitle') || 'Our virtual agent is here to help you'}</p>
         </div>
         </div>
      <div class="chat-footer">
        <div class="input-area">
          <div class="chat-input-wrapper">
            <textarea class="chat-input" placeholder="Message..." rows="1"></textarea>
            <button class="mic-button" aria-label="Voice input">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
              </svg>
            </button>
            <button class="send-button" disabled aria-label="Send message">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="19" x2="12" y2="5"></line>
                <polyline points="5 12 12 5 19 12"></polyline>
              </svg>
            </button>
          </div>
        </div>
        <div class="footer-powered-by">
          <span class="powered-by">${this.getAttribute("powered-by") || 'Powered by Exaado'}</span>
        </div>
      </div>
      </div>

    <chat-button></chat-button>
  `;

    this.shadowRoot.innerHTML = ''; // Clear previous content
    this.shadowRoot.appendChild(styleEl);
    this.shadowRoot.appendChild(template.content.cloneNode(true));

    // إعادة تخزين المراجع للعناصر المهمة بعد التعديل
    this.chatContainer = this.shadowRoot.querySelector('.chat-container');
    this.messagesContainer = this.shadowRoot.querySelector('#messages');
    this.chatInput = this.shadowRoot.querySelector('.chat-input');
    this.sendButton = this.shadowRoot.querySelector('.send-button');
    this.chatButton = this.shadowRoot.querySelector('chat-button');
    this.micButton = this.shadowRoot.querySelector('.mic-button'); // Reference for mic button if needed

    // ... (باقي الكود في _render كما هو، مثل إضافة additionalStyles للترحيب)
      // إضافة الأنماط اللازمة للترحيب (تم تعديل التباعد العلوي)
      const additionalStyles = document.createElement('style');
      additionalStyles.textContent = `
      /* === بداية تعديل الأنماط === */
      .welcome-message {
        display: flex;
        flex-direction: column;
        align-items: center;

        /* --- التعديل هنا: تقليل التباعد العلوي --- */
        padding: 80px 0 10px 0; /* مثال: 30px للأعلى، 20px للأسفل */
        gap: 8px;
        animation: fadeIn 0.5s ease;
      }

      .welcome-avatar {
      margin-bottom: 10px;
         /* لا توجد أنماط خاصة مطلوبة هنا الآن */
      }

      .welcome-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--text-color);
        margin: 0;
        text-align: center;
      }

      .welcome-subtitle {
        font-size: 14px;
        font-weight: 400;
        color: var(--text-secondary);
        margin: 0;
        text-align: center;
      }
      /* === نهاية تعديل الأنماط === */

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
    `;
      this.shadowRoot.appendChild(additionalStyles);
  }

    _setupComponentListeners() { // تم تغيير الاسم
     console.log('🔗 Setting up component listeners (run once)...'); // للتأكد

     // زر فتح الدردشة الرئيسي (خارج الجزء المعاد رسمه)
     // تأكد من أن chatButton موجود (يجب أن يكون موجودًا بعد أول _render)
     if (this.chatButton) {
         // --- هام: تأكد من عدم إضافة المستمع أكثر من مرة ---
         // طريقة بسيطة: استخدام خاصية للإشارة إلى أنه تم الربط
         if (!this.chatButton._listenerAttached) {
              this.chatButton.addEventListener('click', () => {
                  this.toggleChat();
              });
              this.chatButton._listenerAttached = true; // وضع علامة
         }
     } else {
         console.error("Chat button not found for component listener setup.");
     }

     // اختصارات لوحة المفاتيح (على مستوى المستند)
     // --- هام: تأكد من عدم إضافة المستمع أكثر من مرة ---
     if (!document._chatWidgetKeyListenerAttached) {
          document.addEventListener('keydown', (e) => {
              // / لتركيز حقل الإدخال
              // تأكد من أن chatInput موجود ومرئي قبل محاولة التركيز
              if (e.key === '/' && this.isOpen && this.chatInput && document.activeElement !== this.chatInput) {
                  e.preventDefault();
                  this.chatInput.focus();
              }
              // Esc لإغلاق الدردشة
              if (e.key === 'Escape' && this.isOpen) {
                  this.toggleChat();
              }
          });
          document._chatWidgetKeyListenerAttached = true; // وضع علامة
      }

     // --- إزالة الكود الذي تم نقله إلى _setupInternalListeners ---
   }

    // دالة للتعامل مع حدث التمرير
    _handleScroll(event) {
      const currentScrollPosition = this.messagesContainer.scrollTop;

      // إخفاء الهيدر عند التمرير للأسفل
      if (currentScrollPosition > this.lastScrollPosition && currentScrollPosition > 50 && !this.headerCollapsed) {
        this.profileHeader.classList.add('hidden');
        this.headerCollapsed = true;
      }
      // إظهار الهيدر عند التمرير للأعلى
      else if (currentScrollPosition < this.lastScrollPosition && currentScrollPosition < 50 && this.headerCollapsed) {
        this.profileHeader.classList.remove('hidden');
        this.headerCollapsed = false;
      }

      this.lastScrollPosition = currentScrollPosition;
    }

    // دالة التكبير التلقائي لحقل الإدخال
    _autoResizeTextarea() {
      this.chatInput.style.height = 'auto';
      this.chatInput.style.height = (this.chatInput.scrollHeight) + 'px';

      // التأكد من عدم تجاوز الارتفاع الأقصى
      if (this.chatInput.scrollHeight > 150) {
        this.chatInput.style.overflowY = 'auto';
      } else {
        this.chatInput.style.overflowY = 'hidden';
      }
    }

    _addMessage(message) {
    const id = Date.now().toString();
    const timestamp = new Date();
    const fullMessage = {
      id,
      content: message.content,
      sender: message.sender,
      timestamp
    };

    // إضافة الرسالة إلى المصفوفة
    this.messages.push(fullMessage);

    // إنشاء مكون رسالة جديد باستخدام الـ Markdown
    const messageEl = document.createElement('chat-message');
    messageEl.setAttribute('sender', message.sender);
    messageEl.setAttribute('message-id', id);
    messageEl.setAttribute('data-md', message.content); // استخدام سمة data-md للمحتوى

    // دائماً إضافة صورة الـ avatar مع رسائل البوت
    if (message.sender === 'bot') {
      messageEl.setAttribute('avatar', this.getAttribute('avatar') || '');
      messageEl.setAttribute('show-avatar', 'true');  // سمة جديدة للتحكم في إظهار الصورة
    }

    // إضافة المكون للعرض
    this.messagesContainer.appendChild(messageEl);

    // التمرير إلى أسفل
    this._scrollToBottom();

    // إخفاء الاقتراحات عند إرسال أول رسالة
    if (this.messages.length === 2 && this.messages[1].sender === 'user') {
      const suggestions = this.shadowRoot.querySelector('chat-suggestions');
      if (suggestions) {
        suggestions.style.display = 'none';
      }
    }

    return fullMessage;
  }

    _sendMessage() {
      const message = this.chatInput.value.trim();
      if (!message) return;

      // إضافة رسالة المستخدم
      this._addMessage({
        content: message,
        sender: 'user'
      });

      // مسح حقل الإدخال وتعطيل الزر
      this.chatInput.value = '';
      this.chatInput.style.height = 'auto'; // إعادة ضبط ارتفاع الحقل
      this.sendButton.disabled = true;

      // إظهار مؤشر الكتابة الأولي
      this._showTypingIndicator();

      // إرسال الرسالة إلى الخادم
      const apiUrl = this.getAttribute('api-url');
      const projectId = this.getAttribute('project-id');

      console.log(`Sending message to ${apiUrl} with projectId: ${projectId}, sessionId: ${this.sessionId}`);

      this.chatService.sendMessage(apiUrl, {
        message,
        session_id: this.sessionId,
        project_id: projectId
      })
      .then(stream => {
        console.log("Stream connection established", stream);
        let fullResponse = '';
        let liveMessageElement = null; // متغير لتخزين مرجع للرسالة الحية

        stream.onmessage = (event) => {
          // --- التعامل مع قطع البيانات فقط ---
          if (event.type === 'chunk') {
            let data;
            try {
              data = JSON.parse(event.data);
            } catch (err) {
              console.error('Invalid JSON in chunk:', err, event.data);
              return;
            }

            if (data.content) {
              // إخفاء مؤشر الكتابة الأولي عند استلام أول قطعة بيانات
              if (!liveMessageElement) {
                this._hideTypingIndicator(); // إخفاء النقاط ...
                // إنشاء عنصر الرسالة الحية مرة واحدة فقط
                liveMessageElement = this._createLiveMessageElement();
              }

              // بناء الرسالة الحية تدريجياً
              fullResponse += data.content;
              if (liveMessageElement && typeof liveMessageElement.updateContent === 'function') {
                liveMessageElement.updateContent(fullResponse);
              } else if (liveMessageElement) {
                console.warn('liveMessageElement.updateContent is not a function. Falling back to textContent.');
                liveMessageElement.textContent = fullResponse;
              }
              this._scrollToBottom();
            }
          }
          // --- معالجة نهاية البث ---
          else if (event.type === 'end') {
            console.log("Stream ended.");

            // استبدال الرسالة الحية بالنهائية أو إضافتها مباشرة
            if (liveMessageElement) {
              this._hideTypingIndicator(); // تأكد من إخفاء المؤشر هنا أيضاً
            } else if (fullResponse) {
              // حالة نادرة: حدث 'end' بدون 'chunk' ولكن مع استجابة
              this._hideTypingIndicator(); // تأكد من إخفاء المؤشر هنا أيضاً
              this._addMessage({
                content: fullResponse,
                sender: 'bot'
              });
            } else {
              this._hideTypingIndicator();
            }

            // إعادة تهيئة المتغيرات وتمكين الإدخال
            liveMessageElement = null;
            fullResponse = '';
            this.sendButton.disabled = false;
          }
          // --- معالجة الأخطاء المرسلة من الخادم ---
          else if (event.type === 'error') {
            // يمكن أن نستفيد هنا من بيانات JSON أيضاً إذا كانت موجودة
            let errMsg = 'عذراً، حدث خطأ في الخادم.';
            try {
              const parsed = JSON.parse(event.data);
              errMsg = parsed.message || errMsg;
            } catch {
              // إذا لم تكن JSON، نستخدم النص كما هو
              errMsg = event.data || errMsg;
            }
            console.error('Error message from stream:', errMsg);
            this._handleStreamError(errMsg, liveMessageElement);
            liveMessageElement = null;
            fullResponse = '';
            this.sendButton.disabled = false;
          }
          // --- تجاهل أنواع أحداث أخرى مثل tool_call, debug، إلخ. ---
          else {
            console.log(`Ignoring event type: ${event.type}`);
          }
        };

        stream.onerror = (err) => {
          console.error('SSE Connection Error:', err);
          this._handleStreamError('عذراً، حدث خطأ في الاتصال بالبث المباشر.', liveMessageElement);
          liveMessageElement = null; // Reset on error
          fullResponse = '';
          this.sendButton.disabled = false;
        };

        stream.onclose = () => {
          console.log("SSE Stream closed");
          // التعامل مع حالة إغلاق البث قبل وصول حدث 'end'
          if (liveMessageElement) {
            console.warn("Stream closed unexpectedly before 'end'. Finalizing message.");
            // نحول الرسالة الحية إلى رسالة نهائية بإزالتها وإضافة النسخة النهائية
            liveMessageElement.remove();
            this._addMessage({ content: fullResponse, sender: 'bot' });
          }
          this._hideTypingIndicator(); // التأكد من إخفاء المؤشر
          liveMessageElement = null;
          this.sendButton.disabled = false;
        };
      })
      .catch(err => {
        console.error('Failed to initiate stream connection:', err);
        this._hideTypingIndicator();
        this._addMessage({
          content: 'عذراً، تعذر الاتصال بالخادم. يرجى التحقق من اتصالك والمحاولة مرة أخرى.',
          sender: 'bot',
          isError: true
        });
        this.sendButton.disabled = false;
      });
    }

    // دالة مساعدة لإنشاء عنصر الرسالة الحية
    _createLiveMessageElement() {
      this.isTyping = true;

      const liveMessage = document.createElement('chat-message');
      liveMessage.setAttribute('sender', 'bot');
      liveMessage.setAttribute('id', 'live-message');
      liveMessage.setAttribute('data-md', ''); // بداية بمحتوى فارغ للماركداون
      if (this.getAttribute('avatar')) {
        liveMessage.setAttribute('avatar', this.getAttribute('avatar'));
      }
      this.messagesContainer.appendChild(liveMessage);
      this._scrollToBottom();
      return liveMessage;
    }

    // دالة مساعدة موحدة لمعالجة أخطاء البث
    _handleStreamError(errorMessage, liveElement) {
      this._hideTypingIndicator();
      if (liveElement) {
        liveElement.remove();
      }
      this._addMessage({
        content: errorMessage,
        sender: 'bot',
        isError: true
      });
      this.sendButton.disabled = false;
    }

    _showTypingIndicator() {
      this.isTyping = true;

      const typingEl = document.createElement('typing-indicator');
      typingEl.setAttribute('avatar', this.getAttribute('avatar') || '');
      typingEl.id = 'typing-indicator';

      this.messagesContainer.appendChild(typingEl);
      this._scrollToBottom();
    }

    _hideTypingIndicator() {
      this.isTyping = false;

      const typingEl = this.shadowRoot.querySelector('#typing-indicator');
      if (typingEl) {
        typingEl.remove();
      }
    }

    _clearChat() {
      // إزالة جميع الرسائل
      this.messages = [];

      // إفراغ حاوية الرسائل
      while (this.messagesContainer.firstChild) {
        this.messagesContainer.removeChild(this.messagesContainer.firstChild);
      }

      // إعادة إنشاء جلسة جديدة
      this.sessionId = this._generateSessionId();

      // إضافة رسالة الترحيب
      setTimeout(() => {
        this._addMessage({
          content: this.getAttribute('welcome-message') || 'مرحبًا بك! كيف يمكنني مساعدتك اليوم؟',
          sender: 'bot'
        });

        // إظهار الاقتراحات مرة أخرى
        const suggestionsEl = document.createElement('chat-suggestions');
        suggestionsEl.suggestions = [
          'ما هي خدماتكم؟',
          'كيف يمكنني التواصل مع الدعم؟',
        'كيف يمكنني الاشتراك في كورس الزمني؟'
        ];
        this.messagesContainer.appendChild(suggestionsEl);
      }, 300);
    }

     _setupInitialChatState() {
     // إضافة رسالة الترحيب والاقتراحات بعد تأخير بسيط
     setTimeout(() => {
       // التأكد من أن حاوية الرسائل موجودة بعد إعادة الرسم المحتملة
       if (!this.messagesContainer) {
         console.error("Messages container not found after reset.");
         return;
       }

       // إزالة أي رسالة ترحيب نصية قديمة أو اقتراحات إذا وجدت (احتياطي)
       const existingWelcomeMsg = this.messagesContainer.querySelector('chat-message[sender="bot"]');
       const existingSuggestions = this.messagesContainer.querySelector('chat-suggestions');
       if (existingWelcomeMsg && this.messages.length === 0) existingWelcomeMsg.remove(); // فقط إذا كانت الرسائل فارغة
       if (existingSuggestions) existingSuggestions.remove();


       // --- الجزء المنقول من _initialize ---
       // إضافة رسالة الترحيب أولاً (كنص)
       this._addMessage({
         content: this.getAttribute('welcome-message') || 'مرحبًا بك! كيف يمكنني مساعدتك اليوم؟',
         sender: 'bot'
       });

       // --- إضافة الاقتراحات هنا ---
       const suggestionsEl = document.createElement('chat-suggestions');
       suggestionsEl.suggestions = [
         'ما هي خدماتكم؟',
         'كيف يمكنني التواصل مع الدعم؟',
        'كيف يمكنني الاشتراك في كورس الزمني؟'
         // يمكنك تحديث هذه الاقتراحات أو جعلها ديناميكية إذا أردت
       ];
       // تأكد من أن الرسالة الترحيبية تم إضافتها قبل إضافة الاقتراحات
       // قد تحتاج لتأخير بسيط آخر أو استخدام Promise إذا كانت _addMessage غير متزامنة تمامًا
       // لكن بما أنها متزامنة هنا، يمكن إضافتها مباشرة
       this.messagesContainer.appendChild(suggestionsEl);
       this.suggestionsElement = suggestionsEl; // --- تخزين المرجع ---
       this._scrollToBottom(); // التمرير للأسفل بعد إضافة الاقتراحات
       // --- نهاية الجزء المنقول ---

     }, 300); // نفس التأخير المستخدم سابقاً
   }

    toggleChat() {
      console.log('🔘 toggleChat fired! isOpen=', this.isOpen);
      this.isOpen = !this.isOpen;
      if (this.isOpen)  {
      this.chatContainer.classList.add('open');
      localStorage.setItem('chatWidgetOpen', 'true');
    } else {
      this.chatContainer.classList.remove('open');
      localStorage.setItem('chatWidgetOpen', 'false');
    }
  }

    _scrollToBottom() {
      setTimeout(() => {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }, 100);
    }

    _generateSessionId(forceNew = false) {
     // محاولة الحصول على معرف جلسة محفوظ
     const savedSessionId = localStorage.getItem('chatWidgetSessionId');
     if (savedSessionId && !forceNew) { // التحقق من forceNew
       return savedSessionId;
     }

     // إنشاء معرف جديد
     const newSessionId = 'session_' + Math.random().toString(36).substring(2, 15);
     localStorage.setItem('chatWidgetSessionId', newSessionId);
     console.log('Generated new session ID:', newSessionId); // للتصحيح
     return newSessionId;
   }


    connectedCallback() {
      // التحقق من حالة النافذة المحفوظة
      const savedState = localStorage.getItem('chatWidgetOpen');
      if (savedState === 'true') {
        setTimeout(() => this.toggleChat(), 300);
      }
    }



   // ===== دالة جديدة لربط الأحداث الداخلية =====
   _setupInternalListeners() {
     console.log('🔗 Setting up internal listeners...'); // للتأكد

     // التأكد من وجود العناصر قبل ربط الأحداث (هام بعد إعادة الرسم)
     if (!this.sendButton || !this.chatInput || !this.messagesContainer || !this.shadowRoot) {
       console.error("One or more internal elements not found for listener setup.");
       return;
     }

     // --- الكود المنقول من _setupEventListeners ---

     // زر إرسال الرسالة
     this.sendButton.addEventListener('click', () => {
       this._sendMessage();
     });

     // الإرسال عند الضغط على Enter (بدون Shift)
     this.chatInput.addEventListener('keydown', (e) => {
    // فقط Ctrl+Enter يرسل الرسالة
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      this._sendMessage();
    }
    // Pressing plain Enter → يدرج سطرًا جديدًا
  });


     // التكبير التلقائي لحقل الإدخال وتمكين/تعطيل زر الإرسال
     this.chatInput.addEventListener('input', () => {
       this._autoResizeTextarea();
       // تأكد من أن sendButton موجود قبل تعديل حالته
       if(this.sendButton) {
          this.sendButton.disabled = !this.chatInput.value.trim();
       }
     });

     // زر الإغلاق (داخل النافذة)
     const closeButtons = this.shadowRoot.querySelectorAll('.close-btn');
     closeButtons.forEach(btn => {
       btn.addEventListener('click', () => {
         this.toggleChat();
       });
     });

     // زر التحديث (داخل النافذة)
     const refreshButton = this.shadowRoot.querySelector('.refresh-btn');
     if (refreshButton) {
       refreshButton.addEventListener('click', () => {
         this._resetChat();
       });
     } else {
       console.warn("Refresh button (.refresh-btn) not found during internal listener setup.");
     }

     // الاستماع لأحداث اقتراحات الدردشة
     this.shadowRoot.addEventListener('suggestion-clicked', (e) => {
       // تأكد من أن chatInput موجود
       if(this.chatInput) {
         const { suggestion } = e.detail;
         this.chatInput.value = suggestion;
         this._autoResizeTextarea();
         this.sendButton.disabled = false; // يجب تفعيل الزر عند اختيار اقتراح
         this._sendMessage();
       }
     });

     // إضافة مستمع للتمرير لإخفاء الهيدر (إذا كنت تستخدمه)
     // لاحظ أن profileHeader قد يحتاج لإعادة الاستعلام عنه إذا كان داخل الجزء المعاد رسمه
     // إذا كان profileHeader خارج messagesContainer في الـ DOM، قد لا تحتاج لإعادة ربط هذا
     // ولكن إذا كان يتم إعادة إنشائه، ستحتاج لإعادة ربط مستمع التمرير.
     // في الكود الحالي، messagesContainer يتم إعادة الاستعلام عنه، لذا المستمع يجب إعادة ربطه.
     this.messagesContainer.addEventListener('scroll', this._handleScroll.bind(this));


     // --- نهاية الكود المنقول ---

      // قم بتعطيل زر الإرسال مبدئيًا بعد إعادة الربط (لأن حقل الإدخال فارغ)
      if (this.sendButton) {
          this.sendButton.disabled = true;
      }
      // أعد ضبط ارتفاع حقل الإدخال
      if (this.chatInput) {
          this.chatInput.style.height = 'auto';
      }
   }


    attributeChangedCallback(name, oldValue, newValue) {
      // تحديث المكون عند تغيير السمات
      if (oldValue !== newValue) {
        switch (name) {
          case 'direction':
            this.style.direction = newValue || 'rtl';
            break;
        }
      }
    }
  }



  // تسجيل المكون
  customElements.define('chat-widget', ChatWidget);

  // نقطة الدخول الرئيسية للمكتبة

  // نافذة عامة للوصول إلى المكتبة
  window.ChatWidget = {
    init: (options = {}) => {
      // تهيئة الخيارات الافتراضية
      const defaultOptions = {
        projectId: '',
        theme: 'light',
        position: 'bottom-right',
        welcomeMessage: 'مرحبًا بك! كيف يمكنني مساعدتك اليوم؟',
        apiUrl: 'https://exadoo-rxr9.onrender.com/bot/chat/stream',
        direction: 'rtl',
        avatar: '',
        title: 'Exaado Assistant',
        subtitle: 'Our virtual agent is here to help you',
        poweredBy: 'Powered by EXAADO:exaado.com'
      };

      // دمج الخيارات مع الافتراضية
      const config = { ...defaultOptions, ...options };

      // إنشاء مكون الدردشة
      const chatWidget = document.createElement('chat-widget');

      // تعيين السمات
      Object.entries(config).forEach(([key, value]) => {
      if (value == null || value === '') return;  // نتجنّب السمات الفارغة
      // حوّل camelCase إلى kebab-case
      const attr = key.replace(/([A-Z])/g, '-$1').toLowerCase();
      chatWidget.setAttribute(attr, value);
    });

      // إضافة المكون للصفحة
      document.body.appendChild(chatWidget);

      // إرجاع مرجع إلى المكون
      return chatWidget;
    }
  };

  // إعداد مثيل تلقائياً إذا كانت هناك خيارات في نافذة المتصفح
  if (window.ChatWidgetOptions) {
    window.ChatWidget.init(window.ChatWidgetOptions);
  }

})();
//# sourceMappingURL=widget.js.map
